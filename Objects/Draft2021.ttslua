--- New draft style.
-- Authors: Milty, SCPT Matt
-- Script: Darrell
-- #include <~/CrLua/Objects/Draft2021>
--
-- Layout:
--
-- ╔════════════════════════╗
-- ║ SLICES (room for 8)    ║
-- ╠════════════════════════╣
-- ║ FACTIONS (room for 12) ║
-- ╠════════════════════════╣
-- ║ SEATS (6)              ║
-- ╚════════════════════════╝
--
-- Setup:
-- 1. Create (7) roughly balanced slices with the left-equidistant present.
-- 2. Create 6 numbered and colored slice location / seat tokens.
-- 3. Deal (12) random factions to the pool.
-- 4. Assign random turn order.
--
-- Players snake draft one of [1, 2, 3] above.
--
-- Finish:
-- 1. Move players to their chosen seat.
-- 2. Move slices.
-- 3. Select factions on the unpack tool.
-- 4. Assign speaker to slice token #1.
--
-- Buttons:
-- 1. Setup (do setup steps).
-- 2. Reverse Turn Order.
-- 3. Commit (do finish steps).

-------------------------------------------------------------------------------

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _setupHelper = getHelperClient('TI4_SETUP_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

-------------------------------------------------------------------------------

_config = {
    NUM_SLICES = 8,
    NUM_FACTIONS = 12,
}

_state = {}
_deletedItemsBag = false

function onLoad(saveState)
    if saveState and string.len(saveState) > 0 then
        _state = JSON.decode(saveState) or _state
    end
    _deletedItemsBag = _getByName('Bag', 'TI4 Deleted Items')
    self.addContextMenuItem('setup', function() startLuaCoroutine(self, 'setupCoroutine') end)
    self.addContextMenuItem('finish', function() startLuaCoroutine(self, 'finishCoroutine') end)
end

function onSave()
    return JSON.encode(_state)
end

function _getByName(tag, name)
    for _, object in ipairs(getAllObjects()) do
        if object.tag == tag and object.getName() == name then
            return object
        end
    end
    return false
end

-------------------------------------------------------------------------------

function setupCoroutine()
    if not _setupHelper.getPoK() then
        broadcastToAll('Please do setup with PoK enabled first', 'Red')
        return
    end

    -- Get 3 "balanced" blue tiles and 2 red ones.
    _state.tileLists = assert(VolverMilty.makeHands(_config.NUM_SLICES))
    for _, tileList in ipairs(_state.tileLists) do
        VolverMilty.addRedTiles(tileList, 2)
    end
    coroutine.yield(0)

    -- Randomize, separate any adajent anomalies.
    for i, tileList in ipairs(_state.tileLists) do
        _state.tileLists[i] = Slice.randomizeAndFixAdjacentAnomalies(tileList)
    end
    coroutine.yield(0)

    -- Place slices.
    for i, tileList in ipairs(_state.tileLists) do
        print('Slice ' .. i .. ': ' .. table.concat(tileList, ', '))
        local name = 'Draft Slice ' .. i
        local position = Position.draftSlice(i)
        local label = 'Slice ' .. i .. '\n' .. Slice.getLabel(tileList)

        local slice = SliceTokens.spawn(tileList, name, position, label)
        local scale = slice.getScale()
        local s = 0.25
        slice.setScale({ x = scale.x * s, y = scale.y, z = scale.z * s })
        coroutine.yield(0)
    end
    coroutine.yield(0)

    -- Add seat / speaker order tokens.
    for i, color in ipairs(_zoneHelper.zones()) do
        local position = Position.draftSeat(i)
        local label = (i == 1) and 'SPEAKER' or tostring(i)
        SeatTokens.moveToken(color, position, label)
        coroutine.yield(0)
    end
    coroutine.yield(0)

    -- Add draft factions.
    FactionTokens.shuffle()
    for i = 1, _config.NUM_FACTIONS do
        local position = Position.draftFaction(i)
        local rotation = { x = 0, y = 180, z = 0 }
        FactionTokens.placeRandomToken(position, rotation)
        coroutine.yield(0)
    end
    coroutine.yield(0)

    -- Randomize turns.
    local order = {}
    for _, color in ipairs(_zoneHelper.zones()) do
        table.insert(order, color)
    end
    order = assert(VolverMilty.permute(order))
    Turns.enable = false
    Turns.type = 2
    Turns.reverse_order = false
    Turns.order = order
    Turns.turn_color = order[1]
    Turns.enable = true

    return 1
end

function finishCoroutine()

    local zoneColorToPlayer = {}
    local zoneColorToSlice = {}
    local zoneColorToFaction = {}

    -- XXX TODO

    -- Move players to their chosen seat.
    -- TODO ONLY FOR ZONES() COLORS
    local currentColorToPlayer = {}
    for _, player in ipairs(Player.getPlayers()) do
        currentColorToPlayer[player.color] = player
        player.changeColor('Grey')
    end
    coroutine.yield(0)


    -- Move slices.
    -- Select factions on the unpack tool.
    -- Assign speaker to slice token #1.

    SeatTokens.stow()
    coroutine.yield(0)

    FactionTokens.stow()
    coroutine.yield(0)

    return 1
end

-------------------------------------------------------------------------------

Position = {}

--- Where to place draftable slices during setup.
-- @param i (number) : slice index.
-- @return table : {xyz} position.
function Position.draftSlice(i)
    local y = _zoneHelper.getTableY() + 5
    local p0 = { x = 105.00, y = y, z = 6.06}
    local dx = 21 / 4
    local dz = -24.25 / 4
    local col = (i - 1) % 2
    local row = math.floor((i - 1) / 2)
    return {
        x = p0.x + col * dx,
        y = p0.y,
        z = p0.z + row * dz
    }
end

--- Where to place draftable factions during setup.
-- @param i (number) : faction index.
-- @return table : {xyz} position.
function Position.draftFaction(i)
    return {
        x = i * 3,
        y = 5,
        z = 2
    }
end

--- Where to place draftable seats during setup.
-- @param i (number) : seat index.
-- @return table : {xyz} position.
function Position.draftSeat(i)
    return {
        x = i * 3,
        y = 5,
        z = -2
    }
end

-------------------------------------------------------------------------------

VolverMilty = {
    tier1 = { 27, 28, 35, 37, 38, 69, 72, 75 },
    tier2 = { 26, 29, 30, 33, 34, 62, 64, 65, 66, 70, 71, 74, 76 },
    tier3 = { 19, 20, 21, 22, 23, 24, 25, 31, 32, 36, 59, 60, 61, 63, 73 },

    defaultMinR = 2.5,
    defaultMinI = 4,

    minR = false,
    minI = false,
    minTotal = 9,
    maxTotal = 13,

    _redTiles = false,
}

function VolverMilty.permute(list)
    assert(type(list) == 'table')
    math.randomseed(os.time())
    local shuffled = {}
    for i, v in ipairs(list) do
        local j = math.random(1, #shuffled + 1)
        table.insert(shuffled, j, v)
    end
    return shuffled
end

function VolverMilty.makeHands(count)
    assert(type(count) == 'number')
    -- shuffles tile tier list
    local randomTier1 = VolverMilty.permute(VolverMilty.tier1)
    local randomTier2 = VolverMilty.permute(VolverMilty.tier2)
    local randomTier3 = VolverMilty.permute(VolverMilty.tier3)
    local adjCount = { count + 1, count + 1, count + 1 }

    local result = {}
    for i = 1, count do
        local validHand = false
        local adjustTier = { false, false, false }
        local cycles = 0
        while validHand == false do
            -- makes a hand of tiles from each tier
            local hand = { randomTier1[i], randomTier2[i], randomTier3[i] }
            validHand = VolverMilty._verifyHand(hand)
            -- if hand doesn't hit thresholds, goes on to the next hand combination
            if validHand == false then
                if adjustTier[1] == false and adjustTier[2] == false and adjustTier[3] == false then
                    adjustTier[3] = true
                end
                if adjustTier[1] == true then
                    randomTier1[i], randomTier1[adjCount[1]] = randomTier1[adjCount[1]], randomTier1[i]
                    adjustTier[1] = false
                    adjCount[1] = adjCount[1] + 1
                end
                if adjustTier[2] == true then
                    randomTier2[i], randomTier2[adjCount[2]] = randomTier2[adjCount[2]], randomTier2[i]
                    adjustTier[2] = false
                    adjCount[2] = adjCount[2] + 1
                    if adjCount[2] > #VolverMilty.tier2 then
                        adjustTier[1] = true
                        adjustTier[2] = false
                        adjCount[2] = count
                    end
                end
                if adjustTier[3] == true then
                    randomTier3[i], randomTier3[adjCount[3]] = randomTier3[adjCount[3]], randomTier3[i]
                    adjustTier[3] = false
                    adjCount[3] = adjCount[3] + 1
                    if adjCount[3] > #VolverMilty.tier3 then
                        adjustTier[2] = true
                        adjustTier[3] = false
                        adjCount[3] = count
                    end
                end
            end
            cycles = cycles + 1
            if cycles > 1000 then
                error('infinite loop?')
            end
        end
        table.insert(result, { randomTier1[i], randomTier2[i], randomTier3[i] })
    end
    return result
end

function VolverMilty._verifyHand(tileTable)
    local optR = 0.0
    local optI = 0.0
    -- sums hands optimized resources and influence, compares to minimum values
    for i, tile in ipairs(tileTable) do
        local system = _systemHelper.systemFromTile(tile)
        for j, planet in ipairs(system.planets) do
            if planet.resources > planet.influence then
                optR = optR + planet.resources
            elseif planet.influence > planet.resources then
                optI = optI + planet.influence
            else
                optR = optR + 0.5 * planet.resources
                optI = optI + 0.5 * planet.influence
            end
        end
    end
    local minR = VolverMilty.minR or VolverMilty.defaultMinR
    local minI = VolverMilty.minI or VolverMilty.defaultMinI
    local minTotal = VolverMilty.minTotal
    local maxTotal = VolverMilty.maxTotal
    return optR >= minR and optI >= minI and optR + optI >= minTotal and optR + optI <= maxTotal
end

function VolverMilty.addRedTiles(tileTable, count)
    if not VolverMilty._redTiles then
        VolverMilty._redTiles = SystemTiles.getRedTiles()
        VolverMilty.permute(VolverMilty._redTiles)
    end
    for _ = 1, count do
        table.insert(tileTable, table.remove(VolverMilty._redTiles))
    end
end

-------------------------------------------------------------------------------

SliceTokens = {}

--- Create a single object with the home system (grey) and slice tiles,
-- merging tiles into it as child objects.  The overall slice has a safe guid.
function SliceTokens.spawn(tiles, name, position, label)
    local rotation = { x = 0, y = 180, z = 0 }
    local scale = { x = 1.4, y = 1, z = 1.4 }  -- removes gutter

    -- Place a anchor at center so rotation feels natural.
    -- Bury anchor inside other objects.  Do not use the center tile, because
    -- want to make sure have a unique GUID (not shared with a system tile).
    local anchor = SliceTokens._spawnHex(position, rotation, false)
    anchor.setScale({ x = 1, y = 0.5, z = 1 })
    anchor.use_grid = false
    anchor.use_snap_points = true

    -- Home system is shifted.
    local homePos = {
        x = position.x,
        y = position.y,
        z = position.z - 6.06
    }

    local home = SliceTokens._spawnHex(homePos, rotation, label)
    home.setScale(scale)
    if _deletedItemsBag then
        _deletedItemsBag.call('ignoreGuid', home.getGUID())
    end
    anchor.addAttachment(home)

    for i, tile in ipairs(tiles) do
        local tilePos = Slice._getTilePosition(i, homePos, false)
        local tileObject = SliceTokens._cloneSystemTile(tile, tilePos, rotation)
        tileObject.setScale(scale)
        if _deletedItemsBag then
            _deletedItemsBag.call('ignoreGuid', tileObject.getGUID())
        end
        anchor.addAttachment(tileObject)
    end

    return anchor
end

function SliceTokens._spawnHex(position, rotation, label)
    local params = {
        mesh = 'http://cloud-3.steamusercontent.com/ugc/1495712136739988324/528952D008E642AAC461C7B53CFD1CBE16C62F15/',
        collider = 'http://cloud-3.steamusercontent.com/ugc/1495712136739988406/0EF61A7C53392D9A4F95900FE7274EF978D24B84/',
        type = 0,
        material = 3,  -- cardboard
    }
    local hex = spawnObject({
        type              = 'Custom_Model',
        position          = position,
        rotation          = rotation,
        scale             = { x = 1.36, y = 2, z = 1.36 },
        params            = params,
        sound             = false,
        snap_to_grid      = false
    })
    hex.setCustomObject(params)
    hex.setColorTint('Grey')
    if label then
        hex.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = label,
            position       = { x = 0, y = 0.21, z = 0 },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1, y = 1, z = 1 },
            width          = 0,
            height         = 0,
            font_size      = 400,
            font_color     = { r = 0, g = 0, b = 0 }
        })
    end
    return hex
end

function SliceTokens._cloneSystemTile(tile, position, rotation)
    local system = _systemHelper.systemFromTile(tile)
    if not system then
        error('Spawn.tileClone: not such tile ' .. tile)
    end
    local tileData = SystemTiles._getTileData(system.guid)
    if not tileData then
        error('Spawn.tileClone: missing tile ' .. tile)
    end
    tileData.GUID = self.getGUID()  -- allocate a new GUID
    local tileObject = spawnObjectData({
        data              = tileData,
        position          = position,
        rotation          = rotation,
        scale             = { x = 1.36, y = 1.36, z = 1.36 },
        sound             = false,
        snap_to_grid      = false,
    })
    return tileObject
end

-------------------------------------------------------------------------------

SeatTokens = {
    BAG_NAME = 'Randomize Seats',
    _bagGuid = false
}

function SeatTokens._getBag()
    local bag = SeatTokens._bagGuid and getObjectFromGUID(SeatTokens._bagGuid)
    if bag then
        return bag
    end
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Bag' and object.getName() == SeatTokens.BAG_NAME then
            SeatTokens._bagGuid = object.getGUID()
            return object
        end
    end
    error('SeatTokens._getBag: missing "' .. SeatTokens.BAG_NAME .. '"')
end

function SeatTokens.moveToken(color, position, label)
    local token = _getByName('GoPiece', color)
    if token then
        local collide = false
        local fast = true
        token.setPositionSmooth(position, collide, fast)
    else
        local bag = SeatTokens._getBag()
        for _, entry in ipairs(bag.getObjects()) do
            if entry.name == color then
                token = bag.takeObject({
                    position          = position,
                    rotation          = { x = 0, y = 180, z = 0 },
                    smooth            = true,
                    guid              = entry.guid
                })
            end
        end
    end
    if not token then
        error('SeatTokens.moveToken: missing token "' .. color .. '"')
    end
    token.setScale({ x = 2.5, y = 0.5, z = 2.5 })
    if label then
        token.clearButtons()
        token.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = label,
            position       = { x = 0, y = 0.19, z = 0 },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1, y = 1, z = 1 },
            width          = 0,
            height         = 0,
            font_size      = 80,
            font_color     = { r = 0, g = 0, b = 0 }
        })
    end
    return token
end

function SeatTokens.getAll()
    local nameSet = {}
    for _, color in ipairs(_zoneHelper.zones()) do
        nameSet[color] = true
    end
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'GoPiece' and nameSet[object.getName()] then
            table.insert(result, object)
        end
    end
    return result
end

function SeatTokens.stow()
    local bag = SeatTokens._getBag()
    for _, object in ipairs(SeatTokens.getAll()) do
        object.clearButtons()
        bag.putObject(object)
    end
end

-------------------------------------------------------------------------------

FactionTokens = {
    BAG_NAME = 'Pick a Faction to Play',
    _bagGuid = false
}

function FactionTokens._getBag()
    local bag = FactionTokens._bagGuid and getObjectFromGUID(FactionTokens._bagGuid)
    if bag then
        return bag
    end
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Bag' and object.getName() == FactionTokens.BAG_NAME then
            FactionTokens._bagGuid = object.getGUID()
            return object
        end
    end
    error('FactionTokens._getBag: missing "' .. FactionTokens.BAG_NAME .. '"')
end

function FactionTokens.shuffle()
    local bag = FactionTokens._getBag()
    bag.shuffle()
end

function FactionTokens.placeRandomToken(position, rotation)
    local bag = FactionTokens._getBag()
    local token = bag.takeObject({
        position          = position,
        rotation          = rotation,
        smooth            = true,
    })
    return token
end

function FactionTokens.getAll()
    local nameSet = {}
    for _, faction in pairs(_factionHelper.allFactions(true)) do
        nameSet[faction.tokenName .. ' Faction Token'] = true
    end
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Card' and nameSet[object.getName()] then
            table.insert(result, object)
        end
    end
    return result
end

function FactionTokens.stow()
    local bag = FactionTokens._getBag()
    for _, object in ipairs(FactionTokens.getAll()) do
        bag.putObject(object)
    end
end

-------------------------------------------------------------------------------

SystemTiles = {
    _tileGuidToBagGuid = false
}

function SystemTiles.getRedTiles()
    local isPoK = _setupHelper.getPoK()
    local result = {}
    for _, system in pairs(_systemHelper.systems()) do
        local isRedTile = false
        isRedTile = isRedTile or (system.anomalies and #system.anomalies > 0)
        isRedTile = isRedTile or (not system.planets) or (#system.planets == 0)
        if system.tile > 91 then
            isRedTile = false
        end
        if system.tile > 51 and not isPoK then
            isRedTile = false
        end
        if system.hyperlane then
            isRedTile = false
        end
        if system.home then
            isRedTile = false
        end
        if system.tile == 81 then
            isRedTile = false  -- Muaat supernova
        end
        if isRedTile then
            table.insert(result, system.tile)
        end
    end
    return result
end

function SystemTiles._getTileBag(tileGuid)
    assert(type(tileGuid) == 'string')
    if not SystemTiles._tileGuidToBagGuid then
        SystemTiles._tileGuidToBagGuid = {}
        local guidToSystem = _systemHelper.systems()
        local bagSet = {
            ['Blue Planet Tiles'] = true,
            ['Red Anomaly Tiles'] = true,
        }
        local tileToBag = {}
        for _, object in ipairs(getAllObjects()) do
            if object.tag == 'Bag' and bagSet[object.getName()] then
                local bagGuid = object.getGUID()
                for _, entry in ipairs(object.getObjects()) do
                    if guidToSystem[entry.guid] then
                        SystemTiles._tileGuidToBagGuid[entry.guid] = bagGuid
                    end
                end
            end
        end
    end
    local bagGuid = SystemTiles._tileGuidToBagGuid[tileGuid]
    return bagGuid and getObjectFromGUID(bagGuid)
end

function SystemTiles.placeTile(tile, position, rotation)
    local system = _systemHelper.systemFromTile(tile)
    if not system then
        error('SystemTiles._placeTile: not such tile ' .. tile)
    end
    local bag = SystemTiles._getTileBag(system.guid)
    local tileObject = false
    if bag then
        tileObject = bag.takeObject({
            position          = position,
            rotation          = rotation,
            smooth            = true,
            guid              = system.guid
        })
    else
        tileObject = getObjectFromGUID(system.guid)
        if tileObject then
            local collide = false
            local fast = true
            tileObject.setPositionSmooth(position, collide, fast)
            tileObject.setRotationSmooth(rotation, collide, fast)
        end
    end
    if not tileObject then
        error('SystemTiles._placeTile: missing tile ' .. tile)
    end
    Wait.time(function() _systemHelper.lockSystemTile(system.guid) end, 3)
    return tileObject
end

function SystemTiles._getTileData(tileGuid)
    -- Find in bag (expected path).
    local bag = SystemTiles._getTileBag(tileGuid)
    if bag then
        for _, tileData in ipairs(bag.getData().ContainedObjects) do
            if tileData.GUID == tileGuid then
                return tileData
            end
        end
    end
    -- Not found in bag, look on table.
    local tileObject = getObjectFromGUID(tileGuid)
    if tileObject then
        return tileObject.getData()
    end
    error('SystemTiles._getTileData: missing tile ' .. tileGuid)
end

-------------------------------------------------------------------------------

Slice = {
    -- Slice is a mini-map string with tiles in this order.
    OFFSETS = {
        { name = 'leftOfHome', x = -1, z = 0.5 },
        { name = 'frontOfHome', x = 0, z = 1 },
        { name = 'rightOfHome', x = 1, z = 0.5 },
        { name = 'leftEquidistant', x = -1, z = 1.5 },
        { name = 'frontFurther', x = 0, z = 2 },
    }
}

--- Compute "R/I TECH LEGENDARY" label from a list of tile numbers.
function Slice.getLabel(tiles)
    local r = 0
    local i = 0
    local tech = {}
    local legendary = 0
    for _, tile in ipairs(tiles) do
        local system = _systemHelper.systemFromTile(tile)
        for _, planet in ipairs(system.planets or {}) do
            r = r + (planet.resources or 0)
            i = i + (planet.influence or 0)
            if planet.tech then
                table.insert(tech, string.sub(planet.tech, 1, 1):upper())
            end
            if planet.legendary then
                legendary = legendary + 1
            end
        end
    end
    local items = {
        r .. '/' .. i
    }
    if #tech > 0 then
        table.sort(tech)
        table.insert(items, table.concat(tech, ''))
    end
    if legendary > 0 then
        local n = legendary
        table.insert(items, ((n > 1) and n or '') .. 'L')
    end
    return table.concat(items, ' ')
end

--- Swap tiles so no anomalies are adjacent (in this slice).
function Slice.randomizeAndFixAdjacentAnomalies(tiles)
    local tiles = VolverMilty.permute(tiles)

    local anomalySet = {}
    for _, tile in ipairs(tiles) do
        local system = _systemHelper.systemFromTile(tile)
        if system.anomalies and #system.anomalies > 0 then
            anomalySet[tile] = true
        end
    end

    local nameToIndex = {}
    for i, offset in ipairs(Slice.OFFSETS) do
        nameToIndex[offset.name] = i
    end

    local function moveAnomalyNeighbor(moveTile, neighborTile, moveDestination)
        local moveIdx = assert(nameToIndex[moveTile])
        local neighborIdx = assert(nameToIndex[neighborTile])
        local moveDstIdx = assert(nameToIndex[moveDestination])
        local a = assert(tiles[moveIdx])
        local b = assert(tiles[neighborIdx])
        local c = assert(tiles[moveDstIdx])
        if anomalySet[a] and anomalySet[b] then
            tiles[moveIdx] = c
            tiles[moveDstIdx] = a
        end
    end
    moveAnomalyNeighbor('frontOfHome', 'leftOfHome', 'frontFurther')
    moveAnomalyNeighbor('frontOfHome', 'rightOfHome', 'frontFurther')
    moveAnomalyNeighbor('frontOfHome', 'leftEquidistant', 'rightOfHome')
    moveAnomalyNeighbor('frontOfHome', 'frontFurther', 'leftOfHome')
    moveAnomalyNeighbor('leftEquidistant', 'leftOfHome', 'frontFurther')
    moveAnomalyNeighbor('leftEquidistant', 'frontFurther', 'leftOfHome')

    return tiles
end

--- Get position given the home system position and tile index.
-- Optionally apply slice rotation to account for map orientation.
function Slice._getTilePosition(i, p0, applyRotation)
    assert(type(i) == 'number')
    assert(type(p0) == 'table')
    assert(type(applyRotation) == 'boolean')

    local offset = { x = 0, z = 0 }
    if i > 0 then
        offset = assert(Slice.OFFSETS[i])
    end

    local function getOutscribedTileRadius()
        local x = Grid.sizeX or 7
        local y = Grid.sizeY or 7
        assert(x == y, 'error: not a square grid')
        return x / 2.0
    end

    local function getInscribedTileRadius()
        local r = getOutscribedTileRadius()
        local c = r
        local b = r / 2.0
        return math.sqrt(c^2 - b^2)
    end

    -- Compute position.
    local dx = getInscribedTileRadius() * 2 * offset.x
    local dz = getInscribedTileRadius() * 2 * offset.z
    if applyRotation then
        local theta = math.atan2(p0.z, p0.x) - (math.pi / 2)
        local inverse = (theta + math.pi) % (math.pi * 2)
        local dx2 = math.cos(inverse) * dx - math.sin(inverse) * dz
        local dz2 = math.sin(inverse) * dx + math.cos(inverse) * dz
        dx, dz = dx2, dz2
    end
    local pos = {
        x = p0.x + dx,
        y = p0.y,
        z = p0.z + dz,
    }

    -- Convert to hex and back again to be certain pos is grid aligned.
    local y = pos.y
    local hex = _systemHelper.hexFromPosition(pos)
    pos = _systemHelper.hexToPosition(hex)
    pos = {
        x = pos.x,
        y = y,
        z = pos.z
    }

    return pos
end

--- Place system tiles, find tiles in bags or on table.
function Slice.placeTiles(tiles, homeSystemPosition, applyRotation)
    assert(type(offsetToTile) == 'table')
    assert(type(homeSystemPosition) == 'table')
    assert(type(applyRotation) == 'boolean')

    for i, tile in ipairs(tiles) do
        local pos = Slice._getTilePosition(i, homeSystemPosition, applyRotation)
        local rot = { x = 0, y = 180, z = 0 }
        SystemTiles.placeTile(tile, pos, rot)
    end
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)
