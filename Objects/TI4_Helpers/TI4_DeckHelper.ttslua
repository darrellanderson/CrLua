--- Shared deck locations, etc.
-- @author Darrell

-- Users should copy this getHelperClient function, and use via:
--
-- local deckHelper = getHelperClient('TI4_DECK_HELPER')
--
-- Where one can call any main function in this file via the helper.
function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')

local DECKS = {
    ['Public Objectives I'] = {
        transform = {
            parent = 'Public Objectives I Mat',
            deck = {
                position = { x = 7.64, y = 0, z = 0.27 },
                rotation = { x = 0, y = 0, z = 180 },
            },
            extraSnapPoints = {
                p0 = { x = 3.62, y = 0, z = 0.27 },
                d = { x = -2.81, y = 0, z = 0 },
                count = 5
            }
        },
        cardNames = {
            'Corner the Market',
            'Develop Weaponry',
            'Diversify Research',
            'Erect a Monument',
            'Expand Borders',
            'Found Research Outposts',
            'Intimidate Council',
            'Lead From The Front',
            'Negotiate Trade Routes',
            'Sway the Council',
        },
    },
    ['Public Objectives II'] = {
        transform = {
            parent = 'Public Objectives II Mat',
            deck = {
                position = { x = 7.54, y = 0, z = 0.34 },
                rotation = { x = 0, y = 0, z = 180 },
            },
            extraSnapPoints = {
                p0 = { x = 3.69, y = 0, z = 0.34 },
                d = { x = -2.83, y = 0, z = 0 },
                count = 5
            }
        },
        cardNames = {
            'Centralize Galactic Trade',
            'Conquer the Weak',
            'Form Galactic Brain Trust',
            'Found a Golden Age',
            'Galvanize the People',
            'Manipulate Galactic Law',
            'Master the Sciences',
            'Revolutionize Warfare',
            'Subdue the Galaxy',
            'Unify the Colonies',
        },
    },
    ['Secret Objectives'] = {
        transform = {
            parent = 'Cards Mat',
            deck = {
                position = { x = 2.81, y = 0, z = -1.86 },
                rotation = { x = 0, y = 0, z = 180 },
            }
        },
        shuffleOnDiscard = true,
        cardNames = {
            'Adapt New Strategies',
            'Become the Gatekeeper',
            'Control the Region',
            'Cut Supply Lines',
            'Destroy Their Greatest Ship',
            'Establish A Perimeter',
            'Forge An Alliance',
            'Form a Spy Network',
            'Fuel the War Machine',
            'Gather A Mighty Fleet',
            'Learn Secrets of the Cosmos',
            'Make an Example of Their World',
            'Master the Laws of Physics',
            'Mine Rare Metals',
            'Monopolize Production',
            'Occupy the Seat of the Empire',
            'Spark a Rebellion',
            'Threaten Enemies',
            'Turn Their Fleets to Dust',
            'Unveil Flagship',
        },
    },
    ['Agenda'] = {
        transform = {
            parent = 'Cards Mat',
            deck = {
                position = { x = 0.00, y = 0, z = -1.86 },
                rotation = { x = 0, y = 0, z = 180 },
            },
            discard = {
                position = { x = 0.0, y = 0, z = 2.53 },
                rotation = { x = 0, y = 0, z = 0 },
            }
        },
        cardNames = {
            'Anti-Intellectual Revolution',
            'Archived Secret',
            'Arms Reduction',
            'Classified Document Leaks',
            'Colonial Redistribution',
            'Committee Formation',
            'Compensated Disarmament',
            'Conventions of War',
            'Core Mining',
            'Demilitarized Zone',
            'Economic Equality',
            'Enforced Travel Ban',
            'Executive Sanctions',
            'Fleet Regulations',
            'Holy Planet of Ixth',
            'Homeland Defense Act',
            'Imperial Arbiter',
            'Incentive Program',
            'Ixthian Artifact',
            'Judicial Abolishment',
            'Minister of Commerce',
            'Minister of Exploration',
            'Minister of Industry',
            'Minister of Peace',
            'Minister of Policy',
            'Minister of Sciences',
            'Minister of War',
            'Miscount Disclosed',
            'Mutiny',
            'New Constitution',
            'Prophecy of Ixth',
            'Public Execution',
            'Publicize Weapon Schematics',
            'Regulated Conscription',
            'Representative Government',
            'Research Team - Biotic',
            'Research Team - Cybernetic',
            'Research Team - Propulsion',
            'Research Team - Warfare',
            'Seed of an Empire',
            'Senate Sanctuary',
            'Shard of the Throne',
            'Shared Research',
            'Swords to Plowshares',
            'Terraforming Initiative',
            'The Crown of Emphidia',
            'The Crown of Thanlos',
            'Unconventional Measures',
            'Wormhole Reconstruction',
            'Wormhole Research',
        },
    },
    ['Actions'] = {
        transform = {
            parent = 'Cards Mat',
            deck = {
                position = { x = -2.81, y = 0, z = -1.86 },
                rotation = { x = 0, y = 0, z = 180 },
            },
            discard = {
                position = { x = -2.81, y = 0, z = 2.53 },
                rotation = { x = 0, y = 0, z = 0 },
            }
        },
        cardNames = {
            'Ancient Burial Sites',
            'Assassinate Representative',
            'Bribery',
            'Bunker',
            'Confusing Legal Text',
            'Construction Rider',
            'Courageous to the End',
            'Cripple Defenses',
            'Diplomacy Rider',
            'Direct Hit (1)',
            'Direct Hit (2)',
            'Direct Hit (3)',
            'Direct Hit (4)',
            'Disable',
            'Distinguished Councilor',
            'Economic Initiative',
            'Emergency Repairs',
            'Experimental Battlestation',
            'Fighter Prototype',
            'Fire Team',
            'Flank Speed (1)',
            'Flank Speed (2)',
            'Flank Speed (3)',
            'Flank Speed (4)',
            'Focused Research',
            'Frontline Deployment',
            'Ghost Ship',
            'Imperial Rider',
            'In the Silence of Space',
            'Industrial Initiative',
            'Infiltrate',
            'Insubordination',
            'Intercept',
            'Leadership Rider',
            'Lost Star Chart',
            'Lucky Shot',
            'Maneuvering Jets (1)',
            'Maneuvering Jets (2)',
            'Maneuvering Jets (3)',
            'Maneuvering Jets (4)',
            'Mining Initiative',
            'Morale Boost (1)',
            'Morale Boost (2)',
            'Morale Boost (3)',
            'Morale Boost (4)',
            'Parley',
            'Plague',
            'Political Stability',
            'Politics Rider',
            'Public Disgrace',
            'Reactor Meltdown',
            'Reparations',
            'Repeal Law',
            'Rise of a Messiah',
            'Sabotage (1)',
            'Sabotage (2)',
            'Sabotage (3)',
            'Sabotage (4)',
            'Salvage',
            'Shields Holding (1)',
            'Shields Holding (2)',
            'Shields Holding (3)',
            'Shields Holding (4)',
            'Signal Jamming',
            'Skilled Retreat (1)',
            'Skilled Retreat (2)',
            'Skilled Retreat (3)',
            'Skilled Retreat (4)',
            'Spy',
            'Summit',
            'Tactical Bombardment',
            'Technology Rider',
            'Trade Rider',
            'Unexpected Action',
            'Unstable Planet',
            'Upgrade',
            'Uprising',
            'Veto',
            'War Effort',
            'Warfare Rider',
            -- Codex action cards
            'Hack Election',
            'Harness Energy',
            'Blitz',
            'Fighter Conscription',
            'Forward Supply Base',
            'Rally',
            'War Machine (1)',
            'War Machine (2)',
            'War Machine (3)',
            'War Machine (4)',
            'Master Plan',
            'Insider Information',
            'Plagiarize',
            'Scramble Frequency',
            'Solar Flare',
            'Reflective Shielding',
            'Impersonation',
            'Sanction',
            'Counterstroke',
            'Ghost Squad',
        },
    },
    ['Planets'] = {
        transform = {
            parent = 'Cards Mat',
            deck = {
                position = { x = 2.81, y = 0, z = 2.53 },
                rotation = { x = 0, y = 0, z = 180 },
            },
        },
        cardNames = {}
    },
}

local _parentNameToGuid = {}
local _lowerCardNameToDeckAttributes = false
local _discardCardQueue = {}
local _discardDeckQueue = {}
local _waitForDestroy = {}
local _dealQueue = {}
local _dealCoroutineIsActive = false
local _dealCoroutineHeartbeat = false

local function _getParent(parentName)
    local guid = _parentNameToGuid[parentName]
    local parent = guid and getObjectFromGUID(guid)
    if parent then
        return parent
    end
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == parentName then
            _parentNameToGuid[parentName] = object.getGUID()
            return object
        end
    end
    error('Deck Helper: missing "' .. parentName .. '"')
end

local function _getDeckAttributes(cardName)
    assert(type(cardName) == 'string')
    if not _lowerCardNameToDeckAttributes then
        _lowerCardNameToDeckAttributes = {}
        for _, attributes in pairs(DECKS) do
            for _, cardName in ipairs(attributes.cardNames) do
                _lowerCardNameToDeckAttributes[string.lower(cardName)] = attributes
            end
        end
    end
    return _lowerCardNameToDeckAttributes[string.lower(cardName)]
end

local function _getTransform(deckAttributes, deckOrDiscard)
    assert(type(deckAttributes) == 'table' and type(deckOrDiscard) == 'string')

    -- Get the requested transform.
    local transform = deckAttributes.transform[deckOrDiscard]
    if transform then
        local parent = _getParent(deckAttributes.transform.parent)
        local parentRot = parent and parent.getRotation()
        return {
            position = parent and parent.positionToWorld(transform.position) or {
                x = transform.position.x,  -- make a copy, caller may mutate!
                y = transform.position.y,
                z = transform.position.z
            },
            rotation = {
                x = transform.rotation.x + (parentRot and parentRot.x) or 0,
                y = transform.rotation.y + (parentRot and parentRot.y) or 0,
                z = transform.rotation.z + (parentRot and parentRot.z) or 0,
            }
        }
    end
end

local function _getDeck(deckTransform)
    assert(type(deckTransform) == 'table')
    local hits = Physics.cast({
        origin       = deckTransform.position,
        direction    = { x = 0, y = -1, z = 0 },
        type         = 3,  -- box
        size         = { x = 0.1, y = 4, z = 0.1 },
    })

    -- First look for a deck.
    for _, hit in ipairs(hits or {}) do
        if hit.hit_object.tag == 'Deck' then
            return hit.hit_object
        end
    end

    -- Failing that check if there is a single card.
    for _, hit in ipairs(hits or {}) do
        if hit.hit_object.tag == 'Card' then
            return hit.hit_object
        end
    end
end

--- Expose get deck method.
function getDeck(name)
    assert(type(name) == 'string')
    local deckAttributes = DECKS[name]
    local deckTransform = deckAttributes and _getTransform(deckAttributes, 'deck')
    local deck = deckTransform and _getDeck(deckTransform)
    return deck and deck.getGUID()
end

--- Given a card name, which deck contains it?
function getDeckName(cardName)
    assert(type(cardName) == 'string')
    local deckAttributes = _getDeckAttributes(cardName)
    return deckAttributes and deckAttributes.deckName
end

-------------------------------------------------------------------------------

--- Discard this card, optionally removing it from a contiainer.
function discardCard(params)
    assert(type(params) == 'table')
    assert(type(params.guid) == 'string')
    assert(type(params.name) == 'string')
    assert(not params.index or (type(params.index) == 'number' and params.index > 0))
    assert(not params.containerGuid or type(params.containerGuid) == 'string')
    assert(not params.waitForDestroy or type(params.waitForDestroy) == 'boolean')

    local deckAttributes = _getDeckAttributes(params.name)
    if deckAttributes then
        params.deckAttributes = deckAttributes
        if params.waitForDestroy then
            params.waitForDestroy = nil
            _waitForDestroy[params.guid] = function() discardCard(params) end
        else
            table.insert(_discardCardQueue, params)
            Wait.frames(_processCardDiscardQueue, 2 + 2 * (params.index or 0))
        end
        return true
    end
end

function _processCardDiscardQueue()
    local params = table.remove(_discardCardQueue, 1)
    if not params then
        return
    end

    local deckAttributes = assert(params.deckAttributes)
    local transform = _getTransform(deckAttributes, 'discard')
    if not transform then
        transform = _getTransform(deckAttributes, 'deck')
    end

    transform.position.y = transform.position.y + 3 + (params.index or 0) / 10

    local container = false
    local cardObject = false
    if params.containerGuid then
        container = getObjectFromGUID(params.containerGuid)
        if not container then
            -- Container does not exist anymore.
            cardObject = getObjectFromGUID(params.guid)
        elseif container.tag == 'Deck' and container.remainder and container.remainder.getGUID() == params.guid then
            -- Card is the last card in the deck.
            cardObject = container.remainder
        else
            -- Card is presumably in the container.  Verify.
            local found = false
            for _, entry in ipairs(container.getObjects()) do
                if entry.guid == params.guid then
                    found = true
                    break
                end
            end
            assert(found)
        end
    else
        -- Find card on the table.
        cardObject = getObjectFromGUID(params.guid)
    end

    if cardObject then
        cardObject.setLock(false)
        local collide = false
        local fast = true
        cardObject.setPositionSmooth(transform.position, collide, fast)
        cardObject.setRotationSmooth(transform.rotation, collide, fast)
    elseif container then
        local isLocked = container.getLock()
        container.setLock(false)
        cardObject = container.takeObject({
            guid              = params.guid,
            position          = transform.position,
            rotation          = transform.rotation,
            smooth            = false,
        })
        container.setLock(isLocked)
        assert(cardObject)
    else
        error('discard card: no card or container to look for one ("' .. (params.name or '') .. '")')
    end

    if deckAttributes.shuffleOnDiscard then
        if deckAttributes._waitShuffleId then
            Wait.stop(deckAttributes._waitShuffleId)
        end
        local function delayedShuffle()
            deckAttributes._waitShuffleId = nil
            local transform = _getTransform(deckAttributes, 'discard')
            if not transform then
                transform = _getTransform(deckAttributes, 'deck')
            end
            local deck = _getDeck(transform)
            if deck and deck.tag == 'Deck' then
                deck.shuffle()
            end
        end
        deckAttributes._waitShuffleId = Wait.time(delayedShuffle, 2)
    end
end

function discardDeck(params)
    assert(type(params) == 'table')
    assert(type(params.guid) == 'string')
    assert(type(params.name) == 'string')
    assert(not params.index or (type(params.index) == 'number' and params.index > 0))
    assert(not params.containerGuid or type(params.containerGuid) == 'string')
    assert(not params.waitForDestroy or type(params.waitForDestroy) == 'boolean')

    -- The "wait for destroy" flag means the deck is being added to a container
    -- and we should wait for TTS to destroy the (old) version being added to
    -- the bag before retrieving the (new) version from the bag.
    --
    -- In that case, only process it if will discard at least one card.
    local function hasCandidateCard()
        local deck = getObjectFromGUID(params.guid)
        if not deck then
            error('discard deck: missing deck "' .. params.name .. '" (' .. params.guid .. ')')
        end
        if deck.tag ~= 'Deck' then
            error('discard deck: "' .. deck.getName() .. '" is not a deck')
        end
        for _, entry in ipairs(deck.getObjects()) do
            if _getDeckAttributes(entry.name) then
                return true
            end
        end
    end

    if params.waitForDestroy then
        if hasCandidateCard() then
            params.waitForDestroy = nil
            _waitForDestroy[params.guid] = function() discardDeck(params) end
            return true
        end
    else
        table.insert(_discardDeckQueue, params)
        Wait.frames(_processDeckDiscardQueue, 2 + 2 * (params.index or 0))
        return true
    end
end

function _processDeckDiscardQueue()
    local params = table.remove(_discardDeckQueue, 1)
    if not params then
        return
    end

    local container = false
    local deckObject = false
    if params.containerGuid then
        container = getObjectFromGUID(params.containerGuid)
        if container then
            local pos = container.getPosition()
            deckObject = container.takeObject({
                guid              = params.guid,
                position          = { x = pos.x, y = pos.y + 5 + (params.index or 0), z = pos.z },
                smooth            = false,
            })
        end
    else
        deckObject = getObjectFromGUID(params.guid)
    end

    if not deckObject then
        error('discard deck: no deck ("' .. (params.name or '') .. '")')
    end
    Wait.frames(function() deckObject.setLock(true) end, 1)

    local numAccepted = 0
    local numRejected = 0
    for i, entry in ipairs(deckObject.getObjects()) do
        local accepted = discardCard({
            guid = entry.guid,
            name = entry.name,
            containerGuid = deckObject.getGUID(),
            index = i
        })
        if accepted then
            numAccepted = numAccepted + 1
        else
            numRejected = numRejected + 1
        end
    end

    -- If any cards were not discarded, return the remaining deck to any container.
    if numRejected > 0 then
        local function delayedFinish()
            deckObject.setLock(false)
            if deckObject.remainder then
                deckObject = deckObject.remainder
                deckObject.setLock(false)
            end
            if container then
                container.putObject(deckObject)
            end
        end
        Wait.frames(delayedFinish, 6 + 2 * numAccepted)
    end
end

-------------------------------------------------------------------------------

--- Is the given card in its discard pile?
function isDiscard(cardGuid)
    assert(type(cardGuid) == 'string')
    local cardObject = assert(getObjectFromGUID(cardGuid))
    assert(cardObject.tag == 'Card')
    local deckAttributes = _getDeckAttributes(cardObject.getName())
    local discardTransform = deckAttributes and _getTransform(deckAttributes, 'discard')
    if discardTransform then
        local p1 = cardObject.getPosition()
        local p2 = discardTransform.position
        local d = math.sqrt((p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2)
        return d < 1
    end
end

--- Make sure dropped card it not going to wrong deck/discard.
function _verifyCardDrop(cardObject)
    assert(type(cardObject) == 'userdata' and cardObject.tag == 'Card')

    local function insideDeckTransform(deckTransform)
        if deckTransform then
            local p1 = cardObject.getPosition()
            local p2 = deckTransform.position
            local d = math.sqrt((p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2)
            return d < 1 and deckTransform.rotation
        end
    end

    local function insideDeckOrDiscard(deckAttributes)
        local deckTransform = _getTransform(deckAttributes, 'deck')
        local discardTransform = _getTransform(deckAttributes, 'discard')
        return insideDeckTransform(deckTransform) or insideDeckTransform(discardTransform)
    end

    local deckAttributes = _getDeckAttributes(cardObject.getName())
    if not deckAttributes then
        return  -- does not belong to a known deck
    else
        local rotation = insideDeckOrDiscard(deckAttributes)
        if rotation then
            -- Make sure it has the correct rotation.
            local collide = false
            local fast = true
            cardObject.setRotationSmooth(rotation, collide, fast)
            return  -- dropped in the expected deck area.
        end
    end

    for name, otherDeckAttributes in pairs(DECKS) do
        if name ~= deckAttributes.deckName and insideDeckOrDiscard(otherDeckAttributes) then
            local message = {
                'Warning: card from the "',
                deckAttributes.deckName,
                '" deck was dropped in the "',
                otherDeckAttributes.deckName,
                '" area'
            }
            broadcastToAll(table.concat(message, ''), 'Red')
        end
    end
end

-------------------------------------------------------------------------------

function deal(params)
    assert(type(params) == 'table')
    assert(type(params.deck) == 'string')
    assert(type(params.color) == 'string')
    assert(type(params.count) == 'number' and params.count > 0)

    params.deckAttributes = assert(DECKS[params.deck], 'bad deck name')

    local deckWithoutS = string.match(params.deck, '^(.*)s$') or params.deck
    deckWithoutS = string.lower(deckWithoutS)
    printToAll('Dealing ' .. params.count .. ' ' .. deckWithoutS .. ' card' .. (params.count > 1 and 's' or '') .. ' to ' .. params.color)

    table.insert(_dealQueue, params)

    -- Paranoia that an error might kill the deal coroutine but leave it marked
    -- as active.  If active but the heartbeat is too old cancel active status.
    if _dealCoroutineIsActive and _dealCoroutineHeartbeat and Time.time > (_dealCoroutineHeartbeat + 1) then
        _dealCoroutineIsActive = false
        _dealCoroutineHeartbeat = false
    end

    if not _dealCoroutineIsActive then
        _dealCoroutineIsActive = true
        _dealCoroutineHeartbeat = Time.time
        startLuaCoroutine(self, 'dealCoroutine')
    end
end

function dealCoroutine()
    while #_dealQueue > 0 do
        local params = table.remove(_dealQueue, 1)
        local deckTransform = _getTransform(params.deckAttributes, 'deck')
        local deck = _getDeck(deckTransform)

        _dealCoroutineHeartbeat = Time.time

        if deck.remainder then
            deck = deck.remainder
        end
        while deck.spawning do
            _dealCoroutineHeartbeat = Time.time
            coroutine.yield(0)
        end

        -- Deal as many cards as able.
        if deck then
            local dealCount = 0
            if deck.tag == 'Deck' then
                dealCount = math.min(params.count, deck.getQuantity())
            elseif deck.tag == 'Card' then
                dealCount = 1
            end
            params.count = params.count - dealCount
            deck.deal(dealCount, params.color)
            _dealCoroutineHeartbeat = Time.time
            coroutine.yield(0)

            -- Wait a moment while any deal-in-progress cards move away.
            local waitUntil = Time.time + 1
            while Time.time < waitUntil do
                _dealCoroutineHeartbeat = Time.time
                coroutine.yield(0)
            end
        end

        -- If not able to deal all cards shuffle discard.
        if params.count > 0 then
            local discardTransform = _getTransform(params.deckAttributes, 'discard')
            local discard = discardTransform and _getDeck(discardTransform)

            if discard then
                local bounds = discard.getBoundsNormalized()
                local collide = false
                local fast = true
                discard.setPositionSmooth({
                    x = deckTransform.position.x,
                    y = deckTransform.position.y + bounds.size.y / 2 + 0.1,
                    z = deckTransform.position.z
                }, collide, fast)
                discard.setRotationSmooth(deckTransform.rotation, collide, fast)
                _dealCoroutineHeartbeat = Time.time
                coroutine.yield(0)

                -- Give set position smooth time to work.
                local waitUntil = Time.time + 1
                while Time.time < waitUntil or discard.isSmoothMoving() do
                    _dealCoroutineHeartbeat = Time.time
                    coroutine.yield(0)
                end
                _dealCoroutineHeartbeat = Time.time
                coroutine.yield(0)

                if discard.tag == 'Deck' then
                    discard.setName(params.deckAttributes.deckName)
                    discard.shuffle()
                    _dealCoroutineHeartbeat = Time.time
                    coroutine.yield(0)
                end

                -- Re-add to front of queue, reattempt next service.
                table.insert(_dealQueue, 1, params)
            else
                -- Not able to deal all and no discard pile?
                printToAll('Warning: not able to deal ' .. params.count .. ' card' .. (params.count > 1 and 's' or '' ) .. ' from "' .. params.deck .. '" deck to ' .. params.color, 'Red')
            end
        end
    end
    _dealCoroutineIsActive = false
    _dealCoroutineHeartbeat = false
    return 1
end

-------------------------------------------------------------------------------
-- Add top/bottom context menu on Agenda cards to discard to top/bottom.

function isAgendaCard(cardName)
    assert(type(cardName) == 'string')
    assert(DECKS['Agenda'], 'No agenda deck??')
    return getDeckName(cardName) == 'Agenda'
end

local function _putAgendaCard(cardObject, onTop)
    assert(type(cardObject) == 'userdata' and cardObject.tag == 'Card' and type(onTop) == 'boolean')

    -- Cannot use normal discard method as this is not going to the discard pile.
    local transform = _getTransform(DECKS['Agenda'], 'deck')
    assert(transform)

    -- Teleport to near (jump out of hand, if in hand).
    -- DO NOT SET POSITION SMOOTH, GETS PULLED BACK TO HAND!
    local nearby = { x = transform.position.x * 0.8, y = transform.position.y + 5, z = transform.position.z * 0.8 }
    cardObject.setPosition(nearby)
    cardObject.setRotation(transform.rotation)

    -- Wait a moment for card to leave hand, then place.
    local function finishPut()
        -- Smooth to final position.
        transform.position.y = transform.position.y + (onTop and 3 or 0)
        local collide = false
        local fast = false  -- slow so can see it go bottom/top
        cardObject.setPositionSmooth(transform.position, collide, fast)
    end
    Wait.frames(finishPut, 2)
end

function onObjectLeaveContainer(container, leaveObject)
    if leaveObject.tag == 'Card' and isAgendaCard(leaveObject.getName()) then
        local function putTop(playerColor)
            printToAll('Put agenda top', playerColor)
            _putAgendaCard(leaveObject, true)
        end
        local function putBottom(playerColor)
            printToAll('Put agenda bottom', playerColor)
            _putAgendaCard(leaveObject, false)
        end
        leaveObject.addContextMenuItem('Place Agenda Top', putTop, false)
        leaveObject.addContextMenuItem('Place Agenda Bottom', putBottom, false)
    end
end

function onObjectEnterContainer(container, enterObject)
    if enterObject.tag == 'Card' and isAgendaCard(enterObject.getName()) then
        enterObject.clearContextMenu()
    end
end

function onObjectDestroy(dyingObject)
    local guid = dyingObject.getGUID()
    if _waitForDestroy[guid] then
        local callback = _waitForDestroy[guid]
        _waitForDestroy[guid] = nil
        callback()
    end
end

function onObjectDrop(playerColor, droppedObject)
    if droppedObject.tag == 'Card' then
        _verifyCardDrop(droppedObject)
    end
end

-------------------------------------------------------------------------------

-- Helper to read deck positions based on deck locations (hard coded above).
local function _reportDeckPositionsInParentSpace()
    local parentNameSet = {}
    for deckName, deckAttributes in pairs(DECKS) do
        parentNameSet[deckAttributes.transform.parent] = true
    end

    local parentNameToObject = {}
    local deckNameToObject = {}
    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()
        if parentNameSet[name] then
            parentNameToObject[name] = object
        end
        if DECKS[name] then
            deckNameToObject[name] = object
        end
    end

    for deckName, deckAttributes in pairs(DECKS) do
        local deck = assert(deckNameToObject[deckName], 'missing ' .. deckName)
        local parent = assert(parentNameToObject[deckAttributes.transform.parent], 'missing ' .. deckAttributes.transform.parent)
        local p = parent.positionToLocal(deck.getPosition())
        print(table.concat({
            deckName,
            math.floor(p.x * 1000) / 1000,
            math.floor(p.y * 1000) / 1000,
            math.floor(p.z * 1000) / 1000,
        }, ' '))
    end
end

function resetPlanetCardNames()
    local deckAttributes = assert(DECKS['Planets'])
    deckAttributes.cardNames = {}
    for _, system in pairs(_systemHelper.systems()) do
        for _, planet in ipairs(system.planets or {}) do
            table.insert(deckAttributes.cardNames, planet.name)
        end
    end
end

function resetSnapPoints()
    local parentNameToSnapPoints = {}
    for deckName, deckAttributes in pairs(DECKS) do
        local snapPoints = parentNameToSnapPoints[deckAttributes.transform.parent]
        if not snapPoints then
            snapPoints = {}
            parentNameToSnapPoints[deckAttributes.transform.parent] = snapPoints
        end
        if deckAttributes.transform.deck then
            table.insert(snapPoints, {
                position = deckAttributes.transform.deck.position,
                rotation = deckAttributes.transform.deck.position.rotation,
                rotation_snap = true
            })
        end
        if deckAttributes.transform.discard then
            table.insert(snapPoints, {
                position = deckAttributes.transform.discard.position,
                rotation = deckAttributes.transform.discard.position.rotation,
                rotation_snap = true
            })
        end
        if deckAttributes.transform.extraSnapPoints then
            local p0 = deckAttributes.transform.extraSnapPoints.p0
            local d = deckAttributes.transform.extraSnapPoints.d
            for i = 0, deckAttributes.transform.extraSnapPoints.count - 1 do
                table.insert(snapPoints, {
                    position = {
                        x = p0.x + d.x * i,
                        y = p0.y + d.y * i,
                        z = p0.z + d.z * i,
                    },
                    rotation = deckAttributes.transform.deck.position.rotation,
                    rotation_snap = true
                })
            end
        end
    end

    local parentNameToObject = {}
    for _, object in ipairs(getAllObjects()) do
        local snapPoints = parentNameToSnapPoints[object.getName()]
        if snapPoints then
            object.setSnapPoints(snapPoints)
        end
    end
end

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_DECK_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    -- Add deck names to attributes.
    for deckName, attributes in pairs(DECKS) do
        attributes.deckName = deckName
    end

    -- Test methods.
    self.addContextMenuItem('Get locations', _reportDeckPositionsInParentSpace, false)
    self.addContextMenuItem('Discard cards', testDiscardCards, false)
    self.addContextMenuItem('Discard deck', testDiscardDeck, false)
    self.addContextMenuItem('Deal 1', function(color) testDeal(color, 1) end, false)
    self.addContextMenuItem('Deal 3', function(color) testDeal(color, 3) end, false)

    resetPlanetCardNames()
    resetSnapPoints()
end

function testDiscardCards()
    -- Discard any loose cards.
    local cards = {}
    local decks = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Card' then
            print('found ' .. object.getName())
            table.insert(cards, object)
        elseif object.tag == 'Deck' then
            table.insert(decks, object)
        end
    end

    for i, card in ipairs(cards) do
        discardCard({
            guid = card.getGUID(),
            name = card.getName(),
            index = i
        })
    end

    -- Find and discard all the Sabotage cards from inside a deck.
    for _, deck in ipairs(decks) do
        local entries = {}
        for _, entry in ipairs(deck.getObjects()) do
            if string.match(entry.name, '^Sabotage') then
                table.insert(entries, entry)
            end
        end
        for i, entry in ipairs(entries) do
            discardCard({
                guid = entry.guid,
                name = entry.name,
                index = i,
                containerGuid = deck.getGUID()
            })
        end
    end
end

function testDiscardDeck()
    local decks = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Deck' then
            table.insert(decks, object)
        end
    end

    -- Test discard deck.
    for _, deck in ipairs(decks) do
        if deck.getName() == 'Actions' then
            discardDeck({
                guid = deck.getGUID(),
                name = deck.getName(),
                index = nil
            })
        end
    end
end

function testDeal(color, count)
    deal({
        deck = 'Actions',
        color = color,
        count = count,
    })
end

-------------------------------------------------------------------------------
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)
