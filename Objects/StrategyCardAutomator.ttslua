function getHelperClient(helperObjectName)
	local function getHelperObject()
		for _, object in ipairs(getAllObjects()) do
			if object.getName() == helperObjectName then return object end
		end
		error('missing object "' .. helperObjectName .. '"')
	end
	-- Nested tables are considered cross script.  Make a local copy.
	local function copyTable(t)
		if t and type(t) == 'table' then
			local copy = {}
			for k, v in pairs(t) do
				copy[k] = type(v) == 'table' and copyTable(v) or v
			end
			t = copy
		end
		return t
	end
	local helperObject = false
	local function getCallWrapper(functionName)
		helperObject = helperObject or getHelperObject()
		if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
		return function(parameters) return copyTable(helperObject.call(functionName, parameters)) end
	end
	return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _strategyCardHelper = getHelperClient('TI4_STRATEGY_CARD_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')
local _setupHelper = getHelperClient('TI4_SETUP_HELPER')
local _deckHelper = getHelperClient('TI4_DECK_HELPER')
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')
local _technologyHelper = getHelperClient('TI4_TECHNOLOGY_HELPER')


local _customLayout = {
	['assignSpeakerButton'] = {
		tag = 'Button',
		attributes = {
			id = 'politics_primary',
			color = "green",
			textcolor = "black",
			tooltip = "Open menu to assign the speaker",
			text = 'Assign Speaker',
			onClick = "genericFollow(Politics Primary)"
		}
	},
	['technology_primary'] = {
		tag = "Button",
		attributes = {
			id = 'technology_primary',
			color = "green",
			textcolor = "black",
			text = 'Technology Primary',
			onClick = "genericFollow(Technology Primary)"
		}
	},
	['technology_secondary'] = {
		tag = "Button",
		attributes = {
			id = 'technology_secondary',
			color = "green",
			textcolor = "black",
			text = 'Technology Secondary',
			tooltip = "Consumes a strategy token from your strategy pool.",
			onClick = "genericFollow(Technology Secondary)"
		}
	},
	['politicsPopupTable'] = {
		tag = "VerticalLayout",
		attributes = {
			id = "politicsPopup",
			height = "150",
			offsetXY="1000 -80",
			active="false",
			visibility=""
			},
		children = {
			{
				tag = 'Button',
				attributes = {
					id = "politics_popup",
					color = "black",
					textcolor = "white",
					text = "Assign Speaker"
				}

			},
			{
				tag = 'Button',
				attributes = {
					id = "politics_popup",
					color = "green",
					textcolor="black",
					text = "Self",
					onClick = "genericSilent(self)"
				}
			},
			{
				tag = 'Button',
				attributes = {
					id = "politics_popup",
					color = "black",
					textcolor="white",
					text = "Close",
					onClick = "genericSilent(close)"
				}
			}
		}
	},
	['technologyPopupTable'] = {
		tag = "VerticalLayout",
		attributes = {
			id = "COLORPLACEHOLDERtechnologyPopup",
			height = "150",
			offsetXY="1000 -80",
			active="false",
			visibility=""
			},
		children = {
			{
				tag = 'Button',
				attributes = {
					id = "technology_popup",
					color = "black",
					textcolor = "white",
					text = "Select Faction Technology"
				}

			},
			{
				tag = 'Button',
				attributes = {
					id = "technology_popup",
					color = "black",
					textcolor="white",
					text = "Close Menu",
					onClick = "genericSilent(close)"
				}
			}
		}
	},
	["technologyPopupButton"] = {
		tag = "Button",
		attributes = {
		id = "technology_generic",
		onClick = "genericSilent(TECHPLACEHOLDER)",
		textcolor = "black",
		text = "TECHPLACEHOLDER",
		color = "white"
		}
	},
	['colorButton'] = {
		tag = 'Button',
		attributes = {
			textColor = "black",
			fontSize = "14",
			color="COLORPLACEHOLDER",
			text="COLORPLACEHOLDER"
		}
	},
	['colorSelector'] = {
		tag = "HorizontalLayout",
		attributes = {
			id = "colorSelector"
		},
		children = {},
	},
	["tradeAttributes"] = {
		tooltip = "Refresh COLORPLACEHOLDER Player's commodities",
		id = "trade_primary",
		onClick = "tradeSelected(COLORPLACEHOLDER)"
	},
	["politicsPopupAttributes"] = {
		tooltip = "Assign Speaker Token to COLORPLACEHOLDER",
		id = "politics_popup",
		onClick = "genericSilent(COLORPLACEHOLDER)"
	},
	["imperial"] = {
		tag = "HorizontalLayout",
		attributes = { id = "imperial_primary" },
		children = {
			{
				tag = "Button",
				attributes = {
					id = "imperial_primary",
					color = "green",
					textcolor = "black",
					text = "Score Mecatol Rex",
					tooltip = "Only usable if you control Mecatol Rex. VP track is NOT updated automatically.",
					onClick = "genericSilent(Mecatol Rex)"
				}
			},
			{
				tag = "Button",
				attributes = {
					id = "imperial_primary",
					color = "green",
					textcolor = "black",
					text = "Draw Secret",
					onClick = "genericFollow(Imperial Primary)"
				}
			}
		}
	}
}
local _ObjectManual = [[
	Features: \n
	Imperial - Primary and Number: gain command tokens.\n
	All other secondaries consume a (non fleet) strategy token (in strat. pool).\n 
	EXCEPTION: If you have Scepter of Emelpar, the Mahact Agent or the Yssaril with Mahact in game available.\n
	Politics - Speaker: Moves speaker token, Draws 2 Action and Agendas. - Sec.: draws 2 Actioncards\n
	Trade - Prim.: Allocates 3 resources, Refreshes commodities (removes all from comm. pool and gain correct #) 
		- Color: Refreshes colors commodities - Sec.: Refreshes your commodities \n
	Tech - Prim.: Nothing - Tech: Draws the card from tech deck 
		- Faction Tech: Opens a choice popup - Comm Tokens: gain tokens as Necro \n
	Imperial - Score: Only writes message - Secret: Draws secret. - Secondary: Draws secret.
]]

local _workQueue = {
	["leadership"] = {},
	["diplomacy"] = {},
	["politics"] = {},
	["construction"] = {},
	["trade"] = {},
	["warfare"] = {},
	["technology"] = {},
	["imperial"] = {}
}

local backManual = {
	tag = "Panel",
	attributes = {
		position = '0 0 -20',
		rotation = '0 0 90',
		width = 200,
		height = 280,
		padding = '10 10 10 10',
		spacing = 10
	},
	children = {
		{
			tag = "Text",
			attributes = {
				resizeTextForBestFit = "true",
				alignment = "UpperLeft",
				horizontalOverflow = "wrap"
			},
			value = _ObjectManual
		}
	}
}

local _updateUiText = "Please click the 'Update UI' button once all players have chosen a faction. Adds automation features (on first use) and updates the colors listed under politics and trade."

local objectUI = {{
	tag = "VerticalLayout",
	attributes = {
		position = '0 0 2',
		rotation = '0 180 0',
		width = 200,
		height = 280,
		padding = '10 10 10 10',
		spacing = 10,
		scale = '1.35 1.0 0.709'
	},
	children = {
		{
			tag ="Text",
			attributes = {
				fontSize = 25,
				textStyle = "Bold",
				alignment = "MiddleCenter"
			},
			value = "Strategy Card Automator"
		},
		{
			tag = "Button",
			attributes = {
				onClick = "updateUiOnClick",
				fontSize = 18
			},
			value = "Update UI"
		},
		-- Panel as placeholder for the toggle button.
		-- _workQueue is disabled by default
		-- This feature is unavaliable to players (not ready yet! Maybe never.)
		{
			tag = "Panel",
			children = {
				{
					tag = "Text",
					attributes = {
						resizeTextForBestFit = "true",
						alignment = "UpperLeft",
						horizontalOverflow = "wrap"
					},
					value = _updateUiText
				}
			}
		}
		-- {
		-- 	tag="ToggleButton",
		-- 	attributes = {
		-- 		onValueChanged = "toggleWorkQueue",
		-- 		fontSize = 18
		-- 	},
		-- 	value = "Deal cards in order"
		-- }
	}

}}

local _useWorkQueue = false

function onLoad()
	local _colors = Player.getColors()

	for card, _ in pairs(_workQueue) do
		_workQueue[card]['primaryColor'] = nil
		_workQueue[card]['done'] = {}
		_workQueue[card]['job'] = {}

		for _,c in pairs(_colors) do
			_workQueue[card]['done'][c] = false
			_workQueue[card]['job'][c] = false
		end
	end

	--Description on Back of the Object.
	self.UI.setXmlTable({backManual})
	local descriptionText = [[
	Please click 'Update UI' before game.\n\n
	All secondary Actions consume a command token (if no alternative available)\n
	Imperial: gain tokens\n
	Politics: Move speaker, draw agenda and action cards\n
	Construction: Allocate units/command Token\n
	Trade: Gain resources and commodities\n
	Tech: Draw tech cards (and move to faction sheet)\n
	Imperial: Draw secret
	]]
	self.setDescription(descriptionText)
	
	local scaleX = 0.73
	local scaleZ = 1.41
	local rescale = {x=1/scaleX, y=1, z=1/scaleZ}
	self.setScale({x=scaleX,y=1,z=scaleZ})
	self.rotate({x=0,y=0,z=0})
	
	-- update UI button
	self.createButton({
		tooltip = "Adds automation buttons (on first click) and updates Trade and Politics colors.",
		click_function = "updateUiOnClick",
		function_owner = self,
		position = {x=0, y=0.0, z=0},
		rotation = {x=0, y=0, z=180},
		scale = rescale,
		width = 900,
		height = 400,
		font_size = 100,
		label = "Update UI",
		})
	
	-- front text
	self.createButton({
		width = 0,
		height = 0,
		font_size = 120,
		label = "Strategy Card\n Automator",
		rotation = {x=0, y=0, z=180},
		position = {x=0, y=0.0, z=-0.63},
		scale = rescale,
		click_function = "doNothing",
		function_owner = self
		})
	self.createButton({
		width = 0,
		height = 0,
		font_size = 60,
		label = "Please click 'Update UI' once all \n players have chosen a faction",
		font_color = "Red",
		rotation = {x=0, y=0, z=180},
		position = {x=0, y=0.0, z=0.54},
		scale = rescale,
		click_function = "doNothing",
		function_owner = self
		})
	self.createButton({
		width = 0,
		height = 0,
		font_size = 40,
		label = "Description of the automation on the back",
		rotation = {x=0, y=0, z=180},
		position = {x=0, y=0.0, z=0.8},
		scale = rescale,
		click_function = "doNothing",
		function_owner = self
		})
end


function toggleWorkQueue(_, isOn)
	_useWorkQueue = isOn
end

function doNothing()
	return false
end

--------------------------------------------------------------------------------
-------------------------------- MAIN ------------------------------------------
--------------------------------------------------------------------------------

function onStrategyCardButtonClicked(params)
	assert(type(params.player) == 'string')
	assert(type(params.strategyCard) == 'string')
	assert(type(params.value) == 'string')


	local card
	card = string.match(params.strategyCard, "(.*)_.*")
	local action
	action = string.gsub(params.strategyCard, card.."_", "")
	local color = params.player
	local option = params.value

	local secondarySuccessful

	--log("Card:"..card.." Action:"..action .. " Option:"..option.. " Color:".. color)

	--take care of ALL pass and close
	if (action == "close") or (action == "pass") then
		_workQueue[card]['done'][color] = true
		if card=="technology" then
			_closePopupUi(color, color..card.."Popup")
		else
			_closePopupUi(color, card.."Popup")
		end
		local isOpen = UI.getAttribute(card, "active")
		if not isOpen then
			_clearWorkQueue(card)
		end

		if action == "pass" then
			_closeMenu(color,card)
		end

		return
	end

	if (action == "primary") then
		_workQueue[card]["primaryColor"] = color
	end

	-- all secondary actions consume a strategy token (except leadership).
		-- EXCEPTION: if player has scepter of emelpar or is has mahact agent available
		-- or has Yssaril agent available with mahact agent in game.
	-- would be nice to have alt key to choose to use alternative, but not possible in xml buttons.
	if action == "secondary" then
		if not (card == "leadership") then
			secondarySuccessful = _consumeStrategyToken(color)
			if not secondarySuccessful then
				_safeBroadcastToColor("No token in you strategy pool.", color, color)
				return
			end
		end
	end


	-------------------------- Diplomacy ---------------------------------------
	-------------------------- Construction ------------------------------------
	-------------------------- warfare -----------------------------------------
	if (card == "diplomacy") or (card == "warfare") then
		-- only keep open if secondary was not successful
		if (action == "secondary") and (not secondarySuccessful) then
			return
		else
			_closeMenu(color, card)
			return
		end
	end


	-------------------------- Leadership --------------------------------------

	if card == "leadership" then
		if action == "primary" then
			_dealLeadershipCommandTokens(color, 3, {x=0,y=0,z=-1})
		elseif action == "secondary" then
			_dealLeadershipCommandTokens(color, option, {x=0,y=0,z=0})
			_closeMenu(color, card)
		end
		return
	end

	-------------------------- Politics ----------------------------------------

	-- we have the actions primary, secondary, and popup
	if card == "politics" then
		-- assign Speaker Button opens Popup
		if (action == "primary") and (option == "Politics Primary") then
			_openPopupUi(color, card.."Popup")
			return
		-- this is the button "Both Top/Both Bottom/One Each"
		elseif (action == "primary") then
			_closeMenu(color, card)
		end
		--popup has actions "close" and "primary"
		if (action == "popup") then
			if option == "close" then
				_closeMenu(color, card.."Popup")
			else
				-- primary passes "self" or COLOR as option
				local success = _assignSpeaker(color, option)
				if success then
					_dealPoliticsActionCards(color)
					-- wait to deal agendas, then they arrive grouped in the hand.
					Wait.frames(function() _dealPoliticsAgendas(color) end,3)

					_workQueue[card]["done"][color] = true
					if _useWorkQueue then
						_dealWorkQueueCards(card)
					end
					_closePopupUi(color, card.."Popup")
				end
			end
		end
		if (action == "secondary") and secondarySuccessful then
			if _useWorkQueue then
				_workQueue[card]["done"][color] = true
				_workQueue[card]["job"][color] = true
				_dealWorkQueueCards(card)
			else
				_dealPoliticsActionCards(color)
			end
			_closeMenu(color, card)
		end
	end

	--------------------------  Trade ------------------------------------------

	if card == "construction" then
		local constructionSuccessful = false

		if action == "primary" then
			if option == "a Space Dock and a PDS" then
				constructionSuccessful = _allocateConstructionUnits(color, {"PDS", "Space Dock"})
			else
				constructionSuccessful = _allocateConstructionUnits(color, {"PDS", "PDS"})
			end
		end
		if (action == "secondary") and secondarySuccessful then
			constructionSuccessful = _allocateConstructionUnits(color, {"Command Token", string.sub(option, 3, -1)})
		end
		if constructionSuccessful then
			
			_closeMenu(color,card)
		end
	end

	if card == "trade" then
		if action == "primary" then
			--primary passes options "Trade Primary" or COLOR
			if option == "Trade Primary" then
				_gain3Tradegoods(color)
				_refreshCommodities(color)
			else
				_refreshCommodities(option)
			end
		elseif (action == "secondary") and secondarySuccessful then
			_refreshCommodities(color)
			_closeMenu(color, card)
			return
		end
	end

	-------------------------- Technology --------------------------------------

	if card == "technology" then
	-- we only have action == "generic" to work with here.
		if action == "generic" then
			-- passes the tech name as option
			-- option "Faction Tech" opens the faction tech popup COLORtechnologyPopup
			if option == "Faction Tech" then
				_openPopupUi(color, color.."technologyPopup")
			end
			-- picks the tech card and takes care of necro command tokens
			researchTech(color, option)
		elseif action == "popup" and option == "close" then
			_closeMenu(color, color..card.."Popup")
		end
		return
	end

	-------------------------- Imperial ----------------------------------------

	if card == "imperial" then
		-- actions "primary", "secondary"
		if action == "primary" then
			--options ~"gains 1 vp from controlling Mecatol Rex", "Imperial Primary"
			if string.find(option, "Mecatol Rex") then
				-- maybe outsource checking to separate function to not inflate the code?
				if not _isObjectOwner(color, "Mecatol Rex") then
					_safeBroadcastToColor("You do not control Mecatol Rex.", color, color)
				else
					broadcastToAll(_getPlayerFromColor(color).steam_name .." uses Imperial Primary to score 1 VP for Mecatol Rex", color)
					_closeMenu(color, card)
				end
			else
				-- only called if "Mecatol Rex" not clicked.
				_dealImperialSecret(color)
				_closeMenu(color, card)
			end
			if _useWorkQueue then
				_dealWorkQueueCards(card)
			end
		elseif (action == "secondary") and secondarySuccessful then
			if _useWorkQueue then
				_workQueue[card]['job'][color] = true
				_workQueue[card]['done'][color] = true
				_dealWorkQueueCards(card)
			else
				_dealImperialSecret(color)
			end
			_closeMenu(color, card)
		end
	end

end

----------------------------- Work Queue ---------------------------------------
-- i dont like this code.
-- it makes no sense to deal cards in the turn order, as decks are shuffled anyway.
-- should probably take this out.

-- the way this works:
-- once a player has closed his window he is marked as "done" for this strategy card (_workQueue[card]["done"][color] = true)
-- the player who uses a primary action, is marked as the "primaryColor" for this strategy card (_workQueue[card]["primaryColor"] = color)
-- a player who uses the secondary is registered for the pending "job" (_workQueue[card]["job"][color] = true)

-- after each action "_dealWorkQueueCards" is called.
-- _dealWorkQueue iterates over all colors (twice) and searches for the "primaryColor".
-- if primaryColor is not set, the primary action is not done and no cards are dealt.
-- otherwise, starting with the player after primaryColor, while players are "done", cards are dealt if they are registered for a "job".
-- exits when someone in the order is not done yet.

-- when all players are done with the action, (vis == nil) all remaining "jobs" are iterated and get dealt cards,
-- and the workQueue is reset.

--------------------------------------------------------------------------------

function _dealWorkQueueCards(card)
	-- currently disabled
	if not _useWorkQueue then
		return
	end

	if not _workQueue[card]["primaryColor"] then
		return
	end

	--duplicate the colorTable
	local doubleTable = {}
	doubleTable = getSeatedPlayers()
	for _,v in ipairs(getSeatedPlayers()) do
		table.insert(doubleTable, v)
	end

	local function _doWork(card, color)
		if card == "imperial" then
			_dealImperialSecret(color)
		end
		if card == "politics" then
			_dealPoliticsActionCards(color)
		end
		return
	end

	local started = false
	for index,color in ipairs(doubleTable) do

		if color == _workQueue[card]['primaryColor'] then
			started = true
		end
		if started then
			if _workQueue[card]['done'][color] then
				if _workQueue[card]['job'][color] then
					_doWork(card, color)
					_workQueue[card]['job'][color] = false
				end
			else
				return
			end
		end
	end
end


function _clearWorkQueue(card)
-- currently disabled
	if not _useWorkQueue then
		return
	end

	local function _doWork(card, color)
		if card == "imperial" then
			_dealImperialSecret(color)
		end
		if card == "politics" then
			_dealPoliticsActionCards(color)
		end
		return
	end

	for color,job in pairs(_workQueue[card]['job']) do
		for _,c in ipairs(getSeatedPlayers()) do
			if c == color then
				if job then
					_doWork(card, color)
				end
			end
		end
	end

	_workQueue[card]['primaryColor'] = nil
	local _colors = _setupHelper.getSetupColors()
	for _,c in ipairs(_colors) do
		if _workQueue[card]['job'][c] then
		end
		_workQueue[card]['done'][c] = false
		_workQueue[card]['job'][c] = false
	end
end

------------------------------ Custom UI ---------------------------------------

local _legalOptions = { "politicsPopup", "technologyPopup", "secondaryPopup" }

function _testPopupOptions(option, color)
	local legal = false
	for _,o in pairs(_legalOptions) do
		if (color..o == option) or (o == option) then
			legal = true
		end
	end

	if not legal then
		return false
	end

	if UI.getAttributes(option) == nil then
		return false
	else
		return true
	end
end

function _openPopupUi(color, option)
	assert(type(color) == "string")
	assert(type(option) == "string")

	if not _testPopupOptions(option, color) then
		log("Open popup: " .. option .. " not found", "Red")
		if option == color.."technologyPopup" then
			broadcastToAll("Please use the 'Update UI' button on the Automation card.", "Red")
		end
		return
	end

	vis = UI.getAttribute(option, "visibility")
	act = UI.getAttribute(option, "active")
	if vis == "" or vis == nil then
		vis = color
		assert(act=="false", option .. " is active but not visible")
	else
		local i,j = string.find(vis, color)
		if i ~= nil and j ~= nil then
			assert(act=="true", option .. " is visible but not active")
		end
		vis = vis .. "|" .. color
	end

	UI.setAttribute(option, "visibility", vis)
	if act == "false" then
		UI.setAttribute(option, "active", "true")
		act = "true"
	end
end

function _closePopupUi(color, option)
	assert(type(color) == "string")
	assert(type(option) == "string")
	if (not _testPopupOptions(option, color)) then
		return
		--error("Close popup: " .. option .. " not found", "Red")
	end
	_closeMenu(color, option)
end

function _closeAllPopups(color)
	for _,option in pairs(_legalOptions) do
		--not implemented yet !!!!!!!!!!!!!!!!
		if (not option == "secondaryPopup") then
			if option == "technologyPopup" then
				_closePopupUi(option, color..option)
			else
				_closePopupUi(option, color)
			end
		end
	end
end

-- closeMenu (just like in global), but closes all associated Popups
-- if the card is a Popup, we do not want to reset the visibility for all,
-- because we only make the popups selectively visible to players.
--
-- we should probably handle "color..cardPopups" generically, instead of checking for it separately with technology.
-- this would make the implementation of a popup window for secondary action (if alternatives to a strategy token are available) easier.
function _closeMenu(color, card)
	local i, j = string.find(card, "Popup")
	local popup = false
	if i ~= nil and j ~= nil then
		popup = true
		if (not _testPopupOptions(card, color)) then
			return
		end
	end

	local vis = UI.getAttribute(card, "visibility")
	local newVis = vis

	-- try to close associated _popups
	if not popup then

		-- just to be double sure that "done" is registered correctly
		_workQueue[card]['done'][color] = true

		if card == "technology" then
			_closeMenu(color, color..card.."Popup")
		else
			_closeMenu(color, card.."Popup")
		end

		-- reset visibility to true for all
		if vis == nil or vis == "" then
			local seatedPlayers = getSeatedPlayers()
			for p, player in pairs(seatedPlayers) do
				if vis == nil or vis == "" then
					vis = player
				else
					vis = vis .. "|" .. player
				end
			end
		end

	end


	local i, j = string.find(vis, color)
	local l = string.len(vis)
	if i ~= nil and j ~= nil then
		if i == 1 then
			if j == l then
				newVis = ""
			else
				newVis = string.sub(vis,j+2,l)
			end
		else
			if j == l then
				newVis = string.sub(vis,1,i-2)
			else
				newVis = string.sub(vis,1,i-1) .. string.sub(vis,j+2,l)
			end
		end
	end
	if newVis == "" then
		UI.setAttribute(card, "active", "false")
		if not popup then
			broadcastToAll("All players have responded", "Black")
			if _useWorkQueue then
				_clearWorkQueue(card)
			end
		end
	end
	UI.setAttribute(card, "visibility", newVis)
end

------------------------------ build custom UI ---------------------------------

function updateUiOnClick(player, option, alt)
	local colorTable = {}
	local factionTable = {}

	--only if all players have chosen a faction
	for _,color in pairs(getSeatedPlayers()) do
		local faction = _factionHelper.fromColor(color)
		if not faction then
			broadcastToAll('Update UI: ' .. color .. ' has not yet chosen a faction', 'Red')
			return
		end
		table.insert(colorTable, color)
	end
	
	local layout = UI.getXmlTable()

	-- adds a tech primary and secondary to automatically consume the stategy token
	-- removes PoK Buttons from tech UI if not playing with PoK
	layout = _addTechnologyPrimarySecondary(layout)

	-- adds the faction tech popup menu
	layout = _addAutomationTechPopup(layout, colorTable)

	-- adds on "Assign Speaker" button to Politics menu which opens the politics Popup
	layout = _addAutomationPoliticsPopup(layout)

	-- not implemented
	-- layout = _addAutomationSecondaryPopup(layout, colorTable)

	-- add a choice between scoring mecatol rex and drawing a secret
	layout = _addImperialPrimary(layout)


	-- adjusts the colors Table for the assign speaker politicsPopup
	layout = _updateColorSelector(layout, "politicsPopup", colorTable)

	-- adjusts the colors Table for the trade strategycard
	layout = _updateColorSelector(layout, "trade", colorTable)

	UI.setXmlTable(layout)
	broadcastToAll("The strategy card menu has been updated", "Red")
end

function _addTechnologyPrimarySecondary(layout)
-- adds a "Technology Primary" and "Technology Secondary" button to the tech menu.
-- The "Technology Primary" only announces "player uses Technology Primary" but does nothing
-- The "Technology Secondary" consumes a strategy token if necessary
-- If PoK not selected, remove PoK tech buttons from UI

	local technologyIndex = nil

	for majorIndex,menu in ipairs(layout) do
		if menu["attributes"]["id"] == "technology" then
			technologyIndex = majorIndex
		end
	end

	if not technologyIndex then
		error("Add technology primary secondary: No technology item found in ui", 'Red')
		return layout
	end

	for _,o in pairs(layout[technologyIndex]["children"]) do
		if o["attributes"]["id"] == "technology_secondary" then
			return layout
		end
	end

	if not _setupHelper.getPoK() then
		-- remove pok tech from ui

		local techlist = {["greenTechs"] = true, ["yellowTechs"] = true, ["redTechs"] = true, ["blueTechs"] = true}
		local horizontalKeep = {}
		for _,o in pairs(layout[technologyIndex]["children"]) do
			local counter = 1
			if o["tag"] == "HorizontalLayout" and techlist[o["attributes"]["id"]] then
				for iv,v in ipairs(o["children"]) do
					if not (iv == 2) and not (iv == 4) then
						horizontalKeep[counter] = v
						counter = counter + 1
					end
				end
				o["children"] = _deepcopy(horizontalKeep)
			end
		end
	
	end

	table.insert(layout[technologyIndex]["children"], #layout - 1, _customLayout["technology_secondary"])
	-- we no longer add the "Technology Primary" button, as it has no function. 

	
	return layout
end


function _addAutomationTechPopup(layout, colorTable)
-- finds the faction technology from faction.factionTech and adds a popup that opens on click of "Faction Tech" button.
-- the popup has the id color.."technologyPopup", so that each faction has its own factiontech popup
	assert(type(colorTable) == "table")

	local function _buildPopupTable(color)
		local factionPopup = {}
		factionPopup = _deepcopy(_customLayout["technologyPopupTable"])
		factionPopup["attributes"].id = string.gsub(factionPopup["attributes"].id, "COLORPLACEHOLDER", color)

		local faction = _factionHelper.fromColor(color)
		if not faction then
			broadcastToAll("_addAutomationTechPopup: no faction found for " .. color, "Red")
			return factionPopup
		end

		if not faction.factionTech then
			broadcastToAll("_addAutomationTechPopup: no factionTechnology found for " .. color, "Red")
			return factionPopup
		end

		for _,factionTech in ipairs(faction.factionTech) do
			local techPopupButton = _deepcopy(_customLayout["technologyPopupButton"])
			for key,attr in pairs(techPopupButton["attributes"]) do
				techPopupButton["attributes"][key] = string.gsub(attr, "TECHPLACEHOLDER", factionTech)
			end
			table.insert(factionPopup["children"],2,techPopupButton)
		end

		return factionPopup
	end

	local inserted = false
	for _,color in ipairs(colorTable) do
		for index,menu in ipairs(layout) do
			if menu["attributes"]["id"] == (color.."technologyPopup") then
				inserted = true
				-- updates existing COLORtechnologyPopup table in case of changed faction? Just to be sure...
				table.remove(layout, index)
				table.insert(layout, index, _buildPopupTable(color))
				break
			end
		end
		if not inserted then
			table.insert(layout, _buildPopupTable(color))
		end
	end

	return layout
end


-- adds a "Assign Speaker" Button. This opens the politicsPopup.
function _addAutomationPoliticsPopup(layout)
	local politicsIndex = nil

	for majorIndex,menu in ipairs(layout) do
		if menu["attributes"]["id"] == "politicsPopup" then
			return layout
		end
		if menu["attributes"]["id"] == "politics" then
			politicsIndex = majorIndex
		end
	end

	if not politicsIndex then
		error("Add politics popup: No politics item found in ui", 'Red')
		return layout
	end

	-- add the Assign Speaker Button which opens the Popup
	table.insert(layout[politicsIndex]["children"], 2, _customLayout["assignSpeakerButton"])
	-- add the Popup itself
	table.insert(layout, #layout+1, _customLayout["politicsPopupTable"])

	return layout
end


function  _addAutomationSecondaryPopup(layout, factionTable)
-- UI.createButton not available for global UI. It would have been nice to use alt click,
-- to select alternative to using strategy token if available.
-- now consumeStrategyToken just exits if alternative is available to the player and tells the player what her alternative is.
log("_addAutomationSecondaryPopup not implemented yet")
assert(type(factionTable) == "table")
return layout
end

function _addImperialPrimary(layout)
-- adds the option to either score a point for mecatol rex (does nothing) or draw a secret
	local imperialIndex
	for majorIndex,menu in ipairs(layout) do
		if menu["attributes"]["id"] == "imperial" then
			imperialIndex = majorIndex
			break
		end
	end

	if not imperialIndex then
		error("Add imperial primary : No imperial item found in ui", 'Red')
		return layout
	end

	local insertIndex = nil
	local keepTable = {}
	for minorIndex,menu in ipairs(layout[imperialIndex]["children"]) do
		if not (menu["attributes"]["id"] == "imperial_primary") then
			table.insert(keepTable, menu)
		else
			insertIndex = minorIndex
		end
	end

	if not insertIndex then
		error("Add imperial primary: imperial_primary not found. No Substitution possible")
	end

	table.insert(keepTable, insertIndex, _customLayout["imperial"])
	layout[imperialIndex]["children"] = keepTable
	return layout
end

function _updateColorSelector(layout, element, colorTable)
	assert(type(element) == "string")
	log("_updateColors " .. element .. " starting.")
	local keepTable = {}
	local elementIndex = 0

	-- find the table to modify and copy all retained elements to keepTable.
	-- keepTable replaces the old table by selectively not selecting colorSelector elements
	for index,menu in ipairs(layout) do
		if menu["attributes"]["id"] == element then
			elementIndex = index
			for minorIndex,child in ipairs(layout[elementIndex]["children"]) do
				-- keep these entries
				if not (child["attributes"]["id"] == "colorSelector") then
					table.insert(keepTable, #keepTable+1, child)
				end
			end
			break
		end
	end

	local function _getColorButton(element, color)
		local yourbutton = _deepcopy(_customLayout["colorButton"])
		attributes = _deepcopy(_customLayout[element.."Attributes"])
		for key,value in pairs(attributes) do
			yourbutton["attributes"][key] = value
		end
		for key,value in pairs(yourbutton["attributes"]) do
			yourbutton["attributes"][key] = string.gsub(value, "COLORPLACEHOLDER", color)
		end
		return yourbutton
	end

	--make new color list
	--colorTable = { "White", "Blue", "Purple", "Green" }

	local newColorSelector = {}
	local tempSelector = _deepcopy(_customLayout["colorSelector"])

	-- do 3 items per row, except for 4 players. There build 2x2
	local maxButtonsPerRow = 3
	if #colorTable == 4 then
		maxButtonsPerRow = 2
	end

	local colCounter = 1

	for icolor,color in ipairs(colorTable) do
		local mybutton = _getColorButton(element, color)

		tempSelector["children"][colCounter] = _deepcopy(mybutton, {})
		colCounter = colCounter + 1
		--if in last row or row full
		if (icolor == #colorTable) or (icolor%3 == maxButtonsPerRow) then
			table.insert(newColorSelector, #newColorSelector+1, _deepcopy(tempSelector))
			colCounter = 1
			tempSelector =  _customLayout["colorSelector"]
		end
	end

	-- position 3 is hardcoded!!! if this were to change somehow we have a problem!
	for _,newColumn in pairs(newColorSelector) do
		table.insert(keepTable, 3, newColumn)
	end
	layout[elementIndex]["children"] = keepTable

	return layout
end


----------------------------- Leadership ---------------------------------------

function _dealLeadershipCommandTokens(color, count, dpos)
-- count is the number of command tokens to allocate,
-- dz is a global offset, so that primary and secondary command tokens are not stacked (for the primary player)
	assert(type(dpos)=="table")

	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('Allocate command tokens: no faction for ' .. color, 'Red')
		return
	end

	local commandTokensBag = _getByName(faction.tokenName.." Command Tokens Bag", "Bag")

	if not commandTokensBag then
		broadcastToAll('Allocate command tokens: missing ' .. faction.tokenName .. ' Command Tokens Bag', 'Red')
		return
	end

	local commandSheet = getObjectFromGUID(faction.commandSheetGuid)
	if not commandSheet then
		broadcastToAll('Allocate command tokens: missing ' .. color .. ' Command Sheet', 'Red')
		return
	end

	local pos = { x = -0.1, y = 1, z = -5 }
	local dx = -0.4

	-- Do the alloation.  Watch out for an empty bag!
	for i = 1, count do
		if commandTokensBag.getQuantity() == 0 then
			_safeBroadcastToColor('You are out of Command Tokens. Only able to gain ' .. i .. ' Tokens. ', color, color)
			break
		end
		local token = commandTokensBag.takeObject({
			position = commandSheet.positionToWorld({
				x = pos.x + (i * dx) + dpos.x,
				y = pos.y + 1 + (i * 0.25) + dpos.y,
				z = pos.z + dpos.z
			})
		})
		_strategyCardHelper._addUnallocatedCommandToken(token, color)
	end

	_safeBroadcastToColor('You have gained Command Tokens.', color, color)

end

------------------------------ secondary ---------------------------------------

function _consumeStrategyToken(color)
	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('Consume Strategy tokens: no faction for ' .. color, 'Red')
		return
	end
	
	
	local SsruuActive = false
	local JaeMirKanActive = false
	
	
	-- find command token bag
	-- also check if alternate command token payment method available.
	-- if so, message the player and return true
	local commandTokensBag

	if not _setupHelper.getPoK() then
		commandTokensBag = _getByName(faction.tokenName .. " Command Tokens Bag", "Bag")
	else
		for _, object in ipairs(getAllObjects()) do
			local name = object.getName()
			local guid = object.getGUID()
			if object.tag == 'Bag' then
				if name == faction.tokenName .. " Command Tokens Bag" then
					commandTokensBag = object
				end
			end

			if (name == "Jae Mir Kan") then
				JaeMirKanActive = true
				if (faction.name == "The Mahact Gene-Sorcerers") and (not object.is_face_down) then
					_safeBroadcastToColor("Jae Mir Kan is available to you. No Token has been used.", color,color)
					return true
				end
			elseif (faction.name == "The Yssaril Tribes") and (name == "Ssruu") and (not object.is_face_down) then
				SsruuActive = true
			end

			if (name == "Scepter of Emelpar") and (not object.is_face_down) then
				local zoneColor = _zoneHelper.zoneFromPosition(object.getPosition())
				if zoneColor == color then
					_safeBroadcastToColor("Scepter of Emelpar is available to you. No Token has been used.", color, color)
					return true
				end

			end
		end

		if (SsruuActive and JaeMirKanActive) then
			_safeBroadcastToColor("Ssruu is available to you. No Token has been used.", color, color)
			return true
		end
	end

	
	if not commandTokensBag then
		broadcastToAll('Consume Strategy tokens: missing ' .. faction.tokenName .. ' Command Tokens Bag', 'Red')
		return
	end

	local commandSheet = getObjectFromGUID(faction.commandSheetGuid)
	if not commandSheet then
		broadcastToAll('Consume Strategy tokens: missing ' .. color .. ' Command Sheet', 'Red')
		return
	end

	-- todo: change cast and use sheet.positionToLocal instead. check if z > 0 or < 0 or something.
		
	local commandTokenName = faction.tokenName .. " Command Token"
	for _,object in ipairs(getAllObjects()) do
		local name = object.getName()
		if name == commandTokenName then
			local rot = object.getRotation()['z']
			if rot < 90 or rot > 270 then
				local pos = commandSheet.positionToLocal(object.getPosition())
				if pos.x < 2 and pos.x > -4 and pos.z > -0.3 and pos.z < 3.5 then
					commandTokensBag.putObject(object)
					_safeBroadcastToColor("A token has been removed from your strategy pool.", color, color)
					return true
				end
			end
		end
	end

	return false
end

-------------------------------- Politics --------------------------------------

function _moveSpeakerToken(color)
	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('Assign speaker token: no faction selected for ' .. color, 'Red')
		return
	end

	local speakerToken = nil
	speakerToken = _getByName("Speaker Token")

	local commandSheet = getObjectFromGUID(faction.commandSheetGuid)
	if not commandSheet then
		broadcastToAll('Assign speaker token: missing ' .. color .. ' Command Sheet', 'Red')
		return
	end
	local rot = commandSheet.getRotation()
	zone = _zoneHelper.zoneAttributes(color)

	local loc = _getSpeakerLoc(zone)

	speakerToken.setPositionSmooth( loc, false, true )
	speakerToken.setRotation(rot)

	broadcastToAll(color .. " has been assigned the new speaker.", color)
	return true
end

-- Get corner of zone closest to the system.
-- also tested for 7 and 8 players
function _getSpeakerLoc(zone)
	local polygons = zone.polygon

	-- get any z value closest to the system map.
	local minz = math.abs(polygons[1][2])
	local i_minz = 1
	for k,poly in ipairs(polygons) do
		if math.abs(poly[2]) < minz then
			minz = math.abs(poly[2])
			i_minz = k
		end
	end
	local z = polygons[i_minz][2]


	-- get the x value closest to the system map, with the matching z value.
	local minx = math.abs(polygons[i_minz][1])
	local i_minx = 1
	for k,poly in ipairs(polygons) do
		if (z == poly[2]) and (math.abs(poly[1]) <= minx) then
			minx = math.abs(poly[1])
			i_minx = k
		end
	end
	local x = polygons[i_minx][1]

	-- shift the token slightly into the zone.
	if z > 0 then z = z + 3 else z = z - 3 end
	if x > 0 then x = x + 4 else x = x - 4 end

	return {x=x ,y=2, z=z}
end

-- option can be "self" or target "COLOR".
function _assignSpeaker(color, option)
	local res
	if option=="self" then
		res = _moveSpeakerToken(color)
	else
		res = _moveSpeakerToken(option)
	end
	return res
end

function _dealPoliticsActionCards(color)
	local counter = 2

	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('Deal Action Cards: no faction for ' .. color, 'Red')
		return
	end

	local abilitiesSet = {}
	for _, ability in ipairs(faction.abilities) do

		abilitiesSet[ability] = true
	end
	if abilitiesSet['Scheming'] then
		broadcastToAll("Scheming.", color)
		counter = counter + 1
	end

	_deckHelper.deal({
		deck = 'Actions',
		count = counter,
		color = color,
	})
end


function _dealPoliticsAgendas(color)
	_deckHelper.deal({
		deck = 'Agenda',
		count = 2,
		color = color,
	})
end

-------------------------------- Construction ----------------------------------

function _allocateConstructionUnits(color, tokenTable)
-- takes selected units from bags and places them right of token containers
-- if a secondary action is taken, a command token is placed next to the allocated unit

	assert(type(color) == "string")
	assert(type(tokenTable) == "table")
	
	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('Allocate Construction tokens: no faction for ' .. color, 'Red')
		return
	end

	local commandSheet = getObjectFromGUID(faction.commandSheetGuid)
	if not commandSheet then
		broadcastToAll('Allocate Construction tokens: missing ' .. color .. ' Command Sheet', 'Red')
		return
	end

	
	local pos = { x = 15.5, y = 2, z = -9.7 }
	local dx = 1
	local posCommandToken = _deepcopy(pos)
	posCommandToken.x = pos.x + 1.5
	posCommandToken.z = pos.z + 5
	
	for i,unitName in ipairs(tokenTable) do
		if unitName == "Command Token" then
			_dealLeadershipCommandTokens(color, 1, posCommandToken)
		else
			local tokensBag = _getByName(color.." " .. unitName, "Bag")

			if not tokensBag then
				broadcastToAll('Allocate Construction tokens: missing ' .. faction.tokenName .. ' Command Tokens Bag', 'Red')
				return
			end
			-- Do the alloation.  Watch out for an empty bag!
			if tokensBag.getQuantity() == 0 then
				_safeBroadcastToColor('You have no more tokens to construct a ' .. unitName .. '. ', color, color)
				return false
			end
			local token = tokensBag.takeObject({
				position = commandSheet.positionToWorld({
					x = pos.x + (i * dx),
					y = 2,
					z = pos.z
				})
			})
			token.highlightOn("Yellow" , 3)
		end
	end
	
	_safeBroadcastToColor('Your constructed units have been allocated.', color, color)
	return true
end




------------------------------------ Trade -------------------------------------

function _gain3Tradegoods(color)
-- deals one 3xTradegoods token to color. Position on commandsheet is hardcoded.
	local commoditiesBag = false
	commoditiesBag = _getByName("x3 Commodities/Tradegoods Bag", "Infinite")

	if not commoditiesBag then
		broadcastToAll('Dealing Tradegoods: missing x1 Commodities/Tradegoods Bag', 'Red')
		return
	end

	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('Dealing Tradegoods: no faction for ' .. color, 'Red')
		return
	end

	local commandSheet = getObjectFromGUID(faction.commandSheetGuid)
	if not commandSheet then
		broadcastToAll('Dealing Tradegoods: missing ' .. color .. ' Command Sheet', 'Red')
		return
	end

	local rot = commandSheet.getRotation()
	local token = commoditiesBag.takeObject({
		position = commandSheet.positionToWorld({
			--x = 0.57,
			x = 1.2,
			y = 2,
			z = 1.7
			--z = 2.13
		}),
		rotation= {x=rot.x, y=rot.y, z=180}
	})
	_safeBroadcastToColor("You have gained 3 Tradegoods", color, color)
end



function _refreshCommodities(color)
-- gets the number of commodities from the faction.commodities value
-- cache commodities bag. and while we're at it, maybe cache command token bags. and while we're at it, maybe cache everything else aswell.
	
	local commoditiesBag = _getByName("x1 Commodities/Tradegoods Bag", "Infinite")
	
	if not commoditiesBag then
		broadcastToAll('Refresh commodities: missing x1 Commodities/Tradegoods Bag TEST', 'Red')
		return
	end

	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('Refresh commodities: no faction for ' .. color, 'Red')
		return
	end

	if not faction.commodities then
		broadcastToAll("Refresh commodities: commodities not implemented for " .. color, "Red")
	end

	local factionSheet = getObjectFromGUID(faction.factionSheetGuid)
	if not factionSheet then
		broadcastToAll('Allocate command tokens: missing ' .. color .. ' Command Sheet', 'Red')
		return
	end

	-- physics cast makes a table of all objects it hits. type=3 is a rectangle, shape to fit the commodities box.
	local hitlist = Physics.cast({
			origin = factionSheet.positionToWorld({x = -1.07, y = -1, z=0.3}),
			direction = {0, 1, 0},
			type = 3,
			size = {3, 1, 1.8},
			maxdistance = 0,
			debug = false
		})
	-- remove all commodities hit.
	for _, v in pairs(hitlist) do
		local name = v.hit_object.getName()
		if name == string.match(name, ".*Commodities/Tradegoods$") then
			commoditiesBag.putObject(v.hit_object)
		end
	end

	-- positions are relative to faction sheet
	-- No idea what happens when command sheet is flipped. Dont think they land under the table (or hope not)
	-- positions are neatly arranged on the commodities field
	for i = 1,faction.commodities do
		local token = commoditiesBag.takeObject({
			position = factionSheet.positionToWorld({
				x = -0.8-(0.15*math.ceil(i/2)),
				y = 2 + (i*0.01),
				z = 0.25 + ((i+1)%2)*0.16
			}),
			rotation = factionSheet.getRotation()
		})
	end
	_safeBroadcastToColor("Your Commodities have been refreshed", color, color)
end

--------------------------------- Technology -----------------------------------

function researchTech(color, cardName)
	assert(type(color) == 'string')
	assert(type(cardName) == "string")

	local faction = _factionHelper.fromColor(color)
	if not faction then
		broadcastToAll('research Technology: no faction selected for ' .. color, 'Red')
		return
	end

	-- "Faction Tech" handled by onStrategyCardButtonClicked.
	if cardName == "Faction Tech" then
		return

	-- gain command tokens only available to necro
	elseif cardName == "Command Tokens" then
		local abilitiesSet = {}
		for _, ability in ipairs(faction.abilities) do

			abilitiesSet[ability] = true
		end
		if abilitiesSet['Technological Singularity'] then
			_dealLeadershipCommandTokens(color, 3, {x=0,y=0,z=0})
			return
		else
			_safeBroadcastToColor("Can only gain command tokens as Nekro", color, color)
			return
		end
	end

	-- get technology deck
	local deckName = 'Technology Cards'
	local techDeck = false
	local techBoard = false
	local techCardPositionsOnTable = {}
	local techType = _technologyHelper.getTechType(cardName)
	for _,object in ipairs(getAllObjects()) do
		if (color == _zoneHelper.zoneFromPosition(object.getPosition())) then
			if _technologyHelper.getTechType(object.getName()) == techType then
				log(object.getName())
				table.insert(techCardPositionsOnTable, 1, object.getPosition())
			end
			if (object.getName() == "Technology Board") then
				techBoard = object
			end
			if (object.tag == 'Deck') and (object.getName() == deckName) then
				techDeck = object
			end
		end
	end

	if not techDeck then
		broadcastToAll('Research Technology: missing deckname ' .. deckName, color)
		broadcastToAll("If you have researched all your available technologies: Congratulations to you " .. _getPlayerFromColor(color).steam_name .."!", color)
		broadcastToAll("If not, please name your deck of remaining technology cards 'Technology Cards' and leave them in your zone.", color)
		return
	end

	local function _getPosToTechBoard(cardName, techBoard, techDeck)
		local pos
		local dx 
		local dz 
		for _,snap in ipairs(techBoard.getSnapPoints()) do
			if not pos then
				pos = snap.position
			else
				if (not dz) and (snap.position.z < (pos.z - 0.1)) then
					dz = pos.z - snap.position.z
				end
				if (not dx) and (snap.position.x < (pos.x - 0.1)) then
					dx = pos.x - snap.position.x
				end
				if snap.position.x > pos.x then
					pos.x = snap.position.x
				end
				if snap.position.z > pos.z then
					pos.z = snap.position.z
				end
			end
		end
		
		local _columns = {["Blue"]=0, ["Green"]=1, ["Yellow"]=2, ["Red"]=3, ["unitUpgrade"]=4}
		column = _columns[_technologyHelper.getTechType(cardName)]
		pos.x = pos.x - column*dx
	
		local occupied = {}
		for _,cardOnTable in ipairs(techCardPositionsOnTable) do
			onGrid = techBoard.positionToLocal(cardOnTable)
			if math.floor(onGrid.x*10) == math.floor(math.floor(pos.x*10)) then
				table.insert(occupied, 1, math.floor((((onGrid.z-pos.z)/dz ) *10 + 0.5)/10))
			end
		end
		local vacant
		for i = 0,10 do
			vacant=true
			for _,occ in ipairs(occupied) do
				if -i == occ then
					vacant = false
				end
			end
			if vacant then
				pos.z = pos.z - dz*i
				return {position = techBoard.positionToWorld(pos), rotation = techBoard.getRotation()}
			end
		end
		return _getPosToTechDeck(techDeck)
	end

	local function _getPosToFactionSheet(cardName, factionSheet, techDeck)
		-- code copied from setupHelper factionsheetsnappoints
		local rot = techDeck.getRotation()

		local x0 = 1.09
		local dx = (-1.09 * 2) / 3
		local z0 = -0.74
		local dz = (0.74 * 2) / 3

		local counter = 1
		local snapPoints = {}
		for col = 0, 3 do
			for row = 0, 3 do
				if col <= row then
					snapPoints[counter] = {
							x = x0 + col * dx,
							y = 0,
							z = z0 + row * dz
						}
					counter = counter + 1
				end
			end
		end
		local overrides = _unitHelper.getUnitOverrides()
		local pos = snapPoints[_pointorder[overrides[cardName]["upgrade"]]]

		return {position=factionSheet.positionToWorld(pos), rotation=rot}
	end

	local function _getPosToTechDeck(cardName, techDeck)
		-- place cards next to tech deck (take care on which side of the table)
		local pos = techDeck.getPosition()
		local rot = techDeck.getRotation()
		if pos.z > 0 then
			pos.x = pos.x + 4
		else
			pos.x = pos.x - 4
		end
		return {position = pos, rotation = rot}
	end

	local guid = _getEntryGuid(techDeck, cardName)
	if not guid then
		_safeBroadcastToColor('Research Technology: ' .. cardName .. " not found in deck " .. techDeck.getName(), color, color)
		return
	end


	local pos
	if techBoard then
		pos = _getPosToTechBoard(cardName, techBoard, techDeck)
		if _technologyHelper.getTechType() == "unitUpgrade" then
			obj = techDeck.takeObject({
				guid              = guid,
				position          = pos.position,
				rotation          = rot.rotation,
				smooth            = true,
			})
			clone = obj.clone()
			local factionSheet = getObjectFromGUID(faction.factionSheetGuid)
			if not factionSheet then
				broadcastToAll('research Technology: missing ' .. color .. ' Faction Sheet', 'Red')
				return
			end
			clonepos = _getPosToFactionSheet(cardName, factionSheet, techDeck)
			clonepos.position.y = clonepos.position.y + 2
			clone.setPositionSmooth(clonepos.position, false, true)
			clone.setRotation(clonepos.rotation)
			
			_sendOnNewTechnologyResearched(color, cardName)

			return
		end
	else
		-- unit upgades are sent to factionSheet, other tech just put left of deck.
		if techType == "unitUpgrade" then
			local factionSheet = getObjectFromGUID(faction.factionSheetGuid)
			if not factionSheet then
				broadcastToAll('research Technology: missing ' .. color .. ' Faction Sheet', 'Red')
				return
			end
			pos = _getPosToFactionSheet(cardName, factionSheet, techDeck)
		else
			pos = _getPosToTechDeck(cardName, techDeck)
		end
		
		pos.position.y = pos.position.y + 2
	end
	techDeck.takeObject({
		guid              = guid,
		position          = pos.position,
		rotation          = pos.rotation,
		smooth            = true,
	})
	
	_sendOnNewTechnologyResearched(color, cardName)

end

-- searches through container for an item with name matching namePattern and returns its guid
function _getEntryGuid(container, namePattern)
	assert(type(container) == 'userdata' and type(namePattern) == 'string')
	for _, entry in ipairs(container.getObjects()) do
		namePattern = string.gsub(namePattern, "-",".")
		if string.match(entry.name, namePattern) then
			return entry.guid
		end
	end
	return false
end

function _sendToPos(cardName, deckObject, pos)
	return
end

function _sendOnNewTechnologyResearched(playerColor, cardName)
    local handler = 'onNewTechnologyResearched'
    local listeners = {}
    for _, object in ipairs(getAllObjects()) do
        if object.getVar(handler) then
            table.insert(listeners, object.getGUID())
        end
    end
	if #listeners > 0 then
    	local params = {player = playerColor,
		technology = cardName}
	    for i, guid in ipairs(listeners) do
            local function callHandler()
                local listener = getObjectFromGUID(guid)
                if listener then
                    listener.call(handler, params)
                end
            end
            Wait.frames(callHandler, i)
        end
    end
end

----------------------------- Imperial ----------------------------------

function _dealImperialSecret(color)
	-- quiet not implemented yet.
	_deckHelper.deal({
		deck = 'Secret Objectives',
		count = 1,
		color = color
	})

	--	broadcastToColor("You have gained a new secret objective.", color)
end

---------------------------- Utility -------------------------------------

function _isObjectOwner(color, objectName)
	assert(type(color) == "string")
	assert(type(objectName) == "string")

	local objectPosition = false

	for _, o in ipairs(getAllObjects()) do
		local name = o.getName()
		local guid = o.getGUID()
		if name == objectName then
			objectPosition = o.getPosition()
			break
		end
	end

	if not objectPosition then
		return false
	end

	if color == _zoneHelper.zoneFromPosition(objectPosition) then
		return true
	else
		return false
	end
end

function _safeBroadcastToColor(message, playerColor, messageColor)
	for _, player in ipairs(Player.getPlayers()) do
		if player.color == playerColor then
			broadcastToColor(message, playerColor, messageColor)
			return
		end
	end
	broadcastToAll(message, messageColor)
end

function _getPlayerFromColor(color)
	assert(type(color) == "string")
	for _,player in ipairs(Player.getPlayers()) do
		if player.color == color then
			return player
		end
	end
	error(color.. " is not a current playercolor.")
end

-- full deep copy of table o
function _deepcopy(o, seen)
  seen = seen or {}
  if o == nil then return nil end
  if seen[o] then return seen[o] end

  local no
  if type(o) == 'table' then
	no = {}
	seen[o] = no

	for k, v in next, o, nil do
	  no[_deepcopy(k, seen)] = _deepcopy(v, seen)
	end
	setmetatable(no, _deepcopy(getmetatable(o), seen))
  else -- number, string, boolean, etc
	no = o
  end
  return no
end

-- cache function for bags and stuff
local _getByNameCache = {}
function _getByName(name, tag)
	local guid = _getByNameCache[name]
	local object = guid and getObjectFromGUID(guid)
	if object then
		return object 
	end
	if not tag then
		for _, object in ipairs(getAllObjects()) do
			if object.getName() == name then
				_getByNameCache[name] = object.getGUID()
				return object
			end 
		end
	else
		for _, object in ipairs(getAllObjects()) do
			if object.tag == tag then
				if object.getName() == name then
					_getByNameCache[name] = object.getGUID()
					return object
				end
			end
		end
	end
end 