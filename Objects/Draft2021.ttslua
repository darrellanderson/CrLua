--- New draft style.
-- Authors: Milty, SCPT Matt
-- Script: Darrell
-- #include <~/CrLua/Objects/Draft2021>
--
-- Layout:
--
-- ╔════════════════════════╗
-- ║ SLICES (room for 8)    ║
-- ╠════════════════════════╣
-- ║ FACTIONS (room for 12) ║
-- ╠════════════════════════╣
-- ║ SEATS (6)              ║
-- ╚════════════════════════╝
--
-- Setup:
-- 1. Create (7) roughly balanced slices with the left-equidistant present.
-- 2. Create 6 numbered and colored slice location / seat tokens.
-- 3. Deal (9) random factions to the pool.
-- 4. Assign random turn order.
--
-- Players snake draft one of [1, 2, 3] above.
--
-- Finish:
-- 1. Move players to their chosen seat.
-- 2. Move slices.
-- 3. Select factions on the unpack tool.
-- 4. Assign speaker to slice token #1.
--
-- Buttons:
-- 1. Setup (do setup steps).
-- 2. Reverse Turn Order.
-- 3. Commit (do finish steps).

-------------------------------------------------------------------------------

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _setupHelper = getHelperClient('TI4_SETUP_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

-------------------------------------------------------------------------------

_config = {
    NUM_SLICES = 7,
    NUM_FACTIONS = 9,
}

_state = {}
_deletedItemsBag = false
_lastScale = false

function onLoad(saveState)
    if saveState and string.len(saveState) > 0 then
        _state = JSON.decode(saveState) or _state
    end
    _deletedItemsBag = _getByName('Bag', 'TI4 Deleted Items')
    --self.addContextMenuItem('setup', doSetup)
    --self.addContextMenuItem('finish', doFinish)
    self.addContextMenuItem('Reset', doReset)

    self.clearButtons()
    self.createButton({
        click_function = 'doSetup',
        function_owner = self,
        label          = 'Setup',
        position       = { x = 0, y = 0.21, z = -0.6 },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1, y = 1, z = 1 },
        width          = 600,
        height         = 270,
        font_size      = 90,
        tooltip        = 'Place draft slices, factions, and seat tokens',
    })
    self.createButton({
        click_function = 'doReverseTurns',
        function_owner = self,
        label          = 'Reverse Turns',
        position       = { x = 0, y = 0.21, z = 0 },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1, y = 1, z = 1 },
        width          = 600,
        height         = 270,
        font_size      = 90,
        tooltip        = 'Change next player direction (forward / reverse)',
    })
    self.createButton({
        click_function = 'doFinish',
        function_owner = self,
        label          = 'Finish',
        position       = { x = 0, y = 0.21, z = 0.6 },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1, y = 1, z = 1 },
        width          = 600,
        height         = 270,
        font_size      = 90,
        tooltip        = 'Move players to their drafted seats, factions, and slices (found in the drafting player\'s area)',
    })

    _maybeDrawBox()
end

function onSave()
    return _state and JSON.encode(_state)
end

function onHover(player_color)
    _maybeDrawBox()
end

function onPickUp(player_color)
    _maybeDrawBox()
end

function onDrop(player_color)
    _maybeDrawBox()
end

function _maybeDrawBox()
    local scale = self.getScale()
    if not _lastScale or _lastScale.x ~= scale.x or _lastScale.z ~= scale.z then
        _lastScale = scale
        Position.drawBox()
    end
end

function _getByName(tag, name)
    for _, object in ipairs(getAllObjects()) do
        if object.tag == tag and object.getName() == name then
            return object
        end
    end
    return false
end

-------------------------------------------------------------------------------

function doReverseTurns()
    Turns.reverse_order = not Turns.reverse_order
    local message = Turns.reverse_order and 'reverse' or 'forward'
    printToAll('Snake order: ' .. message, 'Yellow')
end

function doSetup()
    startLuaCoroutine(self, 'setupCoroutine')
end
function doFinish()
    startLuaCoroutine(self, 'finishCoroutine')
end
function doReset()
    startLuaCoroutine(self, 'resetCoroutine')
end

function setupCoroutine()
    if not _setupHelper.getPoK() then
        broadcastToAll('Please do setup with PoK enabled first', 'Red')
        return 1
    end

    -- Put away any existing draft parts (start from scratch).
    SeatTokens.stow()
    coroutine.yield(0)

    FactionTokens.stow()
    coroutine.yield(0)

    SliceTokens.stow()
    coroutine.yield(0)

    -- Get 3 "balanced" blue tiles and 2 red ones.
    _state.tileLists = assert(VolverMilty.makeHands(_config.NUM_SLICES))
    VolverMilty.addRedTiles(_state.tileLists, 2)
    coroutine.yield(0)

    -- Randomize, separate any adajent anomalies.
    for i, tileList in ipairs(_state.tileLists) do
        _state.tileLists[i] = Slice.randomizeAndFixAdjacentAnomalies(tileList)
    end
    coroutine.yield(0)

    -- Place slices.
    for i, tileList in ipairs(_state.tileLists) do
        printToAll('Slice ' .. i .. ': ' .. table.concat(tileList, ', '), 'Yellow')
        local name = SliceTokens.getSliceName(i)
        local position = Position.draftSlice(i)
        local label = name .. '\n' .. Slice.getLabel(tileList)
        local slice = SliceTokens.spawn(tileList, name, label, position, self.getRotation())
        local scale = slice.getScale()
        local s = 0.25
        slice.setScale({ x = scale.x * s, y = scale.y, z = scale.z * s })
        coroutine.yield(0)
        coroutine.yield(0)
    end
    coroutine.yield(0)

    -- Add seat / speaker order tokens.
    for i, color in ipairs(_zoneHelper.zones()) do
        local position = Position.draftSeat(i)
        local label = (i == 1) and 'SPEAKER' or tostring(i)
        SeatTokens.moveToken(color, label, position, self.getRotation())
        coroutine.yield(0)
    end
    coroutine.yield(0)

    -- Add draft factions.
    FactionTokens.shuffle()
    for i = 1, _config.NUM_FACTIONS do
        local position = Position.draftFaction(i)
        FactionTokens.placeRandomToken(position, self.getRotation())
        coroutine.yield(0)
    end
    coroutine.yield(0)

    -- Randomize turns.
    local order = {}
    for _, color in ipairs(_zoneHelper.zones()) do
        table.insert(order, color)
    end
    order = assert(VolverMilty.permute(order))
    Turns.enable = false
    Turns.type = 2
    Turns.reverse_order = false
    Turns.order = order
    Turns.turn_color = order[1]
    Turns.enable = true
    printToAll('Draft order: ' .. table.concat(order, ', '), 'Yellow')

    return 1
end

function finishCoroutine()
    if not _setupHelper.getPoK() then
        broadcastToAll('SCPT draft: please do setup with PoK enabled first', 'Red')
        return 1
    end

    -- Gather per-player choices.
    local errors = false
    local colorToChoices = {}
    for _, color in ipairs(_zoneHelper.zones()) do
        colorToChoices[color] = {
            player = false,
            sliceTiles = false,
            factionTokenName = false,
            seatColor = false
        }
    end

    for _, player in ipairs(Player.getPlayers()) do
        local color = player.color
        local choices = color and colorToChoices[color]
        if choices then
            choices.player = player
        end
    end
    coroutine.yield(0)

    for _, object in ipairs(SliceTokens.getAll()) do
        local zone = _zoneHelper.zoneFromPosition(object.getPosition())
        local choices = zone and colorToChoices[zone]
        if choices then
            if choices.sliceTiles then
                errors = errors or {}
                table.insert(errors, zone .. ' has multiple slice tokens')
            else
                local sliceIndex = SliceTokens.getSliceIndex(object)
                local sliceTiles = _state.tileLists[sliceIndex]
                choices.sliceTiles = assert(sliceTiles)
            end
        end
    end
    for zone, choices in pairs(colorToChoices) do
        if not choices.sliceTiles then
            errors = errors or {}
            table.insert(errors, zone .. ' does not have a slice token')
        end
    end
    coroutine.yield(0)

    for _, object in ipairs(FactionTokens.getAll()) do
        local zone = _zoneHelper.zoneFromPosition(object.getPosition())
        local choices = zone and colorToChoices[zone]
        if choices then
            if choices.factionTokenName then
                errors = errors or {}
                table.insert(errors, zone .. ' has multiple faction tokens')
            else
                local name = object.getName()
                local factionTokenName = string.match(name, '^(.*) Faction Token$')
                choices.factionTokenName = assert(factionTokenName)
            end
        end
    end
    for zone, choices in pairs(colorToChoices) do
        if not choices.factionTokenName then
            errors = errors or {}
            table.insert(errors, zone .. ' does not have a faction token')
        end
    end
    coroutine.yield(0)

    for _, object in ipairs(SeatTokens.getAll()) do
        local zone = _zoneHelper.zoneFromPosition(object.getPosition())
        local choices = zone and colorToChoices[zone]
        if choices then
            if choices.seatColor then
                errors = errors or {}
                table.insert(errors, zone .. ' has multiple seat/color tokens')
            else
                local color = object.getName()
                if colorToChoices[color] then
                    choices.seatColor = color
                end
            end
        end
    end
    for zone, choices in pairs(colorToChoices) do
        if not choices.seatColor then
            errors = errors or {}
            table.insert(errors, zone .. ' does not have a valid seat token')
        end
    end
    coroutine.yield(0)

    -- Abort if anything is amiss.
    if errors then
        local message = 'Error: ' .. table.concat(errors, ', ')
        broadcastToAll(message, 'Red')
        return 1
    end

    for i, color in ipairs(_zoneHelper.zones()) do
        local choices = assert(colorToChoices[color])
        local message = {
            '(' .. i .. ')',
            choices.player and choices.player.steam_name or color,
            'drafted',
            choices.factionTokenName,
            'in',
            choices.seatColor,
            'with slice {',
            table.concat(choices.sliceTiles, ', '),
            '}'
        }
        message = table.concat(message, ' ')
        printToAll(message, color)
    end
    coroutine.yield(0)

    -- Put away draft items.
    SeatTokens.stow()
    coroutine.yield(0)

    FactionTokens.stow()
    coroutine.yield(0)

    SliceTokens.stow()
    coroutine.yield(0)

    -- Move players to their chosen seat.
    for _, choices in pairs(colorToChoices) do
        if choices.player then
            choices.player.changeColor('Grey')
            coroutine.yield(0)
            coroutine.yield(0)
        end
    end
    for _, choices in pairs(colorToChoices) do
        if choices.player then
            choices.player.changeColor(choices.seatColor)
            coroutine.yield(0)
            coroutine.yield(0)
        end
    end

    -- Move slices.
    for _, choices in pairs(colorToChoices) do
        local seatColor = assert(choices.seatColor)
        local zoneAttrs = assert(_zoneHelper.zoneAttributes(seatColor))
        local tiles = assert(choices.sliceTiles)
        local p0 = assert(zoneAttrs.homeSystemPosition)
        local applyRotation = true
        Slice.placeTiles(tiles, p0, applyRotation)
        coroutine.yield(0)
        coroutine.yield(0)
    end

    -- Setup faction on selector.
    for _, choices in pairs(colorToChoices) do
        local seatColor = assert(choices.seatColor)
        local factionTokenName = assert(choices.factionTokenName)
        _selectFaction(seatColor, factionTokenName)
        coroutine.yield(0)
    end

    -- Assign speaker to slice token #1.
    local speakerToken = _getByName('Generic', 'Speaker Token')
    if speakerToken then
        local zoneAttrs = _zoneHelper.zonesAttributes()[1]
        local pos = {
            x = zoneAttrs.center.x,
            y = zoneAttrs.center.y + 5,
            z = zoneAttrs.center.z + 6 * (zoneAttrs.center.z < 0 and 1 or -1)
        }
        local rot = {
            x = 0,
            y = zoneAttrs.rotation.y,
            z = 0
        }
        local collide = false
        local fast = false
        speakerToken.setPositionSmooth(pos, collide, fast)
        speakerToken.setRotationSmooth(rot, collide, fast)
    end

    return 1
end

function resetCoroutine()
    SeatTokens.stow()
    coroutine.yield(0)

    FactionTokens.stow()
    coroutine.yield(0)

    SliceTokens.stow()
    coroutine.yield(0)

    return 1
end

-------------------------------------------------------------------------------

Position = {
    -- p0 is relative to self top-right corner.
    p0 = { x = -3, y = 3, z = 3 },
    dx = -5,
    dz = 5,

    SLICE_COLS = 3,
    FACTION_COLS = 3,
    SEAT_COLS = 2,
}

function Position._pos(col, row)
    -- Apply scale to p0, but not to offset.
    local bounds = self.getBoundsNormalized().size
    local scale = self.getScale()
    local p0 = {
        x = ((-bounds.x / 2) + Position.p0.x) / scale.x,
        y = Position.p0.y / scale.y,
        z = ((-bounds.z / 2) + Position.p0.z) / scale.z,
    }
    local offset = {
        x = col * Position.dx / scale.x,
        y = 0,
        z = row * Position.dz / scale.z,
    }
    local localPos = {
        x = p0.x + offset.x,
        y = p0.y + offset.y,
        z = p0.z + offset.z,
    }
    return self.positionToWorld(localPos)
end

--- Where to place draftable slices during setup.
-- @param i (number) : slice index.
-- @return table : {xyz} position.
function Position.draftSlice(i)
    local col = (i - 1) % Position.SLICE_COLS
    local row = math.floor((i - 1) / Position.SLICE_COLS)
    return Position._pos(col, row)
end

--- Where to place draftable factions during setup.
-- @param i (number) : faction index.
-- @return table : {xyz} position.
function Position.draftFaction(i)
    local col = (i - 1) % Position.FACTION_COLS
    local row = math.floor((i - 1) / Position.FACTION_COLS)
    col = col + Position.SLICE_COLS
    return Position._pos(col, row)
end

--- Where to place draftable seats during setup.
-- @param i (number) : seat index.
-- @return table : {xyz} position.
function Position.draftSeat(i)
    local col = (i - 1) % Position.SEAT_COLS
    local row = math.floor((i - 1) / Position.SEAT_COLS)
    col = col + Position.SLICE_COLS + Position.FACTION_COLS
    return Position._pos(col, row)
end

function Position.drawBox()
    local cols = Position.SLICE_COLS + Position.FACTION_COLS + Position.SEAT_COLS
    local rows = 0
    rows = math.max(rows, math.ceil(_config.NUM_SLICES / Position.SLICE_COLS))
    rows = math.max(rows, math.ceil(_config.NUM_FACTIONS / Position.FACTION_COLS))
    rows = math.max(rows, math.ceil(#_zoneHelper.zones() / Position.SEAT_COLS))

    local bounds = self.getBoundsNormalized().size
    local scale = self.getScale()

    local left = (bounds.x / 2) / scale.x
    local top = (-bounds.z / 2) / scale.z
    local right = (-(bounds.x / 2) + Position.p0.x + Position.dx * (cols - 0.5)) / scale.x
    local bottom = (-(bounds.z / 2) + Position.p0.z + Position.dz * (rows - 0.5)) / scale.z

    local thickness = 0.1
    right = right + thickness
    bottom = bottom + thickness

    self.setVectorLines({
        {
            points         = {
                { x = left, y = 0.1, z = top },
                { x = right, y = 0.1, z = top },
                { x = right, y = 0.1, z = bottom },
                { x = left, y = 0.1, z = bottom },
            },
            color          = 'White',
            thickness      = thickness,
            rotation       = { x = 0, y = 0, z = 0 },
            loop           = true,
            square         = true
        },
    })
end

-------------------------------------------------------------------------------

VolverMilty = {
    tier1 = { 27, 28, 35, 37, 38, 69, 72, 75 },
    tier2 = { 26, 29, 30, 33, 34, 62, 64, 65, 66, 70, 71, 74, 76 },
    tier3 = { 19, 20, 21, 22, 23, 24, 25, 31, 32, 36, 59, 60, 61, 63, 73 },

    defaultMinR = 2.5,
    defaultMinI = 4,

    minR = false,
    minI = false,
    minTotal = 9,
    maxTotal = 13,
}

function VolverMilty.permute(list)
    assert(type(list) == 'table')
    math.randomseed(os.time())
    local shuffled = {}
    for i, v in ipairs(list) do
        local j = math.random(1, #shuffled + 1)
        table.insert(shuffled, j, v)
    end
    return shuffled
end

function VolverMilty.makeHands(count)
    assert(type(count) == 'number')
    -- shuffles tile tier list
    local randomTier1 = VolverMilty.permute(VolverMilty.tier1)
    local randomTier2 = VolverMilty.permute(VolverMilty.tier2)
    local randomTier3 = VolverMilty.permute(VolverMilty.tier3)
    local adjCount = { count + 1, count + 1, count + 1 }

    local result = {}
    for i = 1, count do
        local validHand = false
        local adjustTier = { false, false, false }
        local cycles = 0
        while validHand == false do
            -- makes a hand of tiles from each tier
            local hand = { randomTier1[i], randomTier2[i], randomTier3[i] }
            validHand = VolverMilty._verifyHand(hand)
            -- if hand doesn't hit thresholds, goes on to the next hand combination
            if validHand == false then
                if adjustTier[1] == false and adjustTier[2] == false and adjustTier[3] == false then
                    adjustTier[3] = true
                end
                if adjustTier[1] == true then
                    randomTier1[i], randomTier1[adjCount[1]] = randomTier1[adjCount[1]], randomTier1[i]
                    adjustTier[1] = false
                    adjCount[1] = adjCount[1] + 1
                end
                if adjustTier[2] == true then
                    randomTier2[i], randomTier2[adjCount[2]] = randomTier2[adjCount[2]], randomTier2[i]
                    adjustTier[2] = false
                    adjCount[2] = adjCount[2] + 1
                    if adjCount[2] > #VolverMilty.tier2 then
                        adjustTier[1] = true
                        adjustTier[2] = false
                        adjCount[2] = count
                    end
                end
                if adjustTier[3] == true then
                    randomTier3[i], randomTier3[adjCount[3]] = randomTier3[adjCount[3]], randomTier3[i]
                    adjustTier[3] = false
                    adjCount[3] = adjCount[3] + 1
                    if adjCount[3] > #VolverMilty.tier3 then
                        adjustTier[2] = true
                        adjustTier[3] = false
                        adjCount[3] = count
                    end
                end
            end
            cycles = cycles + 1
            if cycles > 1000 then
                error('infinite loop?')
            end
        end
        table.insert(result, { randomTier1[i], randomTier2[i], randomTier3[i] })
    end
    return result
end

function VolverMilty._verifyHand(tileTable)
    local optR = 0.0
    local optI = 0.0
    -- sums hands optimized resources and influence, compares to minimum values
    for i, tile in ipairs(tileTable) do
        local system = _systemHelper.systemFromTile(tile)
        for j, planet in ipairs(system.planets) do
            if planet.resources > planet.influence then
                optR = optR + planet.resources
            elseif planet.influence > planet.resources then
                optI = optI + planet.influence
            else
                optR = optR + 0.5 * planet.resources
                optI = optI + 0.5 * planet.influence
            end
        end
    end
    local minR = VolverMilty.minR or VolverMilty.defaultMinR
    local minI = VolverMilty.minI or VolverMilty.defaultMinI
    local minTotal = VolverMilty.minTotal
    local maxTotal = VolverMilty.maxTotal
    return optR >= minR and optI >= minI and optR + optI >= minTotal and optR + optI <= maxTotal
end

function VolverMilty.addRedTiles(hands, count)
    local redTiles = SystemTiles.getRedTiles()
    redTiles = VolverMilty.permute(redTiles)
    for _, hand in ipairs(hands) do
        for _ = 1, count do
            local tile = assert(table.remove(redTiles))
            table.insert(hand, tile)
        end
    end
end

-------------------------------------------------------------------------------

SliceTokens = {}

--- Create a single object with the home system (grey) and slice tiles,
-- merging tiles into it as child objects.  The overall slice has a safe guid.
function SliceTokens.spawn(tiles, name, label, position, rotation)
    assert(type(tiles) == 'table')
    assert(type(name) == 'string')
    assert(type(label) == 'string')
    assert(type(position) == 'table')
    assert(type(rotation) == 'table')

    local spawnRotation = { x = 0, y = 180, z = 0 }
    local scale = { x = 1.4, y = 1, z = 1.4 }  -- removes gutter

    -- Use a grid aligned position, move to requested position later
    -- (getTilePosition forces grid alignment).
    local positionGrid = Slice._getTilePosition(0, position, false)

    -- Place a anchor at center so rotation feels natural.
    -- Bury anchor inside other objects.  Do not use the center tile, because
    -- want to make sure have a unique GUID (not shared with a system tile).
    local anchor = SliceTokens._spawnHex(positionGrid, spawnRotation, false)
    anchor.setScale({ x = 1, y = 0.5, z = 1 })
    anchor.use_grid = false
    anchor.use_snap_points = true
    if name then
        anchor.setName(name)
    end

    -- Home system is "south" of center by one grid unit.
    local homePos = {
        x = positionGrid.x,
        y = positionGrid.y,
        z = positionGrid.z - 6.06
    }

    -- Label gets dropped when attaching, place label on anchor later.
    local home = SliceTokens._spawnHex(homePos, spawnRotation, false)
    home.setScale(scale)
    if _deletedItemsBag then
        _deletedItemsBag.call('ignoreGuid', home.getGUID())
    end
    anchor.addAttachment(home)

    for i, tile in ipairs(tiles) do
        local tilePos = Slice._getTilePosition(i, homePos, false)
        local tileObject = SliceTokens._cloneSystemTile(tile, tilePos, spawnRotation)
        tileObject.setScale(scale)
        if _deletedItemsBag then
            _deletedItemsBag.call('ignoreGuid', tileObject.getGUID())
        end
        anchor.addAttachment(tileObject)
    end

    if label then
        anchor.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = label,
            position       = { x = 0, y = 0.31, z = 6.06 },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1, y = 1, z = 1 },
            width          = 0,
            height         = 0,
            font_size      = 400,
            font_color     = { r = 0, g = 0, b = 0 }
        })

    end

    anchor.setPosition(position)
    anchor.setRotation(rotation)
    return anchor
end

function SliceTokens._spawnHex(position, rotation, label)
    assert(type(position) == 'table')
    assert(type(rotation) == 'table')
    assert((not label) or type(label) == 'string')

    local params = {
        mesh = 'http://cloud-3.steamusercontent.com/ugc/1495712136739988324/528952D008E642AAC461C7B53CFD1CBE16C62F15/',
        collider = 'http://cloud-3.steamusercontent.com/ugc/1495712136739988406/0EF61A7C53392D9A4F95900FE7274EF978D24B84/',
        type = 0,
        material = 3,  -- cardboard
    }
    local hex = spawnObject({
        type              = 'Custom_Model',
        position          = position,
        rotation          = rotation,
        scale             = { x = 1.36, y = 2, z = 1.36 },
        params            = params,
        sound             = false,
        snap_to_grid      = false
    })
    hex.setCustomObject(params)
    hex.setColorTint('Grey')
    hex.use_grid = false
    hex.use_snap_points = false
    if label then
        hex.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = label,
            position       = { x = 0, y = 1.35, z = 0 },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1, y = 1, z = 1 },
            width          = 0,
            height         = 0,
            font_size      = 400,
            font_color     = { r = 0, g = 0, b = 0 }
        })
    end
    return hex
end

function SliceTokens._cloneSystemTile(tile, position, rotation)
    local system = _systemHelper.systemFromTile(tile)
    if not system then
        error('Spawn.tileClone: not such tile ' .. tile)
    end
    local tileData = SystemTiles._getTileData(system.guid)
    if not tileData then
        error('Spawn.tileClone: missing tile ' .. tile)
    end
    local tileObject = spawnObjectData({
        data              = tileData,
        position          = position,
        rotation          = rotation,
        scale             = { x = 1.36, y = 1.36, z = 1.36 },
        sound             = false,
        snap_to_grid      = false,
    })
    tileObject.use_grid = false
    tileObject.use_snap_points = false
    return tileObject
end

function SliceTokens.getSliceIndex(sliceToken)
    local letter = string.match(sliceToken.getName(), '^Slice (.)$')
    if letter then
        local startPos, endPos = string.find('ABCDEFGHIJKLMNOPQRSTUVWXYZ', letter)
        return startPos
    end
end

function SliceTokens.getSliceName(index)
    assert(type(index) == 'number')
    local letter = string.sub('ABCDEFGHIJKLMNOPQRSTUVWXYZ', index, index)
    return 'Slice ' .. assert(letter)
end

function SliceTokens.getAll()
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Generic' and SliceTokens.getSliceIndex(object) then
            table.insert(result, object)
        end
    end
    return result
end

function SliceTokens.stow()
    for _, object in ipairs(SliceTokens.getAll()) do
        if _deletedItemsBag then
            _deletedItemsBag.call('ignoreGuid', object.getGUID())
        end
        destroyObject(object)
    end
end

-------------------------------------------------------------------------------

SeatTokens = {
    BAG_NAME = 'Randomize Seats',
    _bagGuid = false
}

function SeatTokens._getBag()
    local bag = SeatTokens._bagGuid and getObjectFromGUID(SeatTokens._bagGuid)
    if bag then
        return bag
    end
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Bag' and object.getName() == SeatTokens.BAG_NAME then
            SeatTokens._bagGuid = object.getGUID()
            return object
        end
    end
    error('SeatTokens._getBag: missing "' .. SeatTokens.BAG_NAME .. '"')
end

function SeatTokens.moveToken(color, label, position, rotation)
    assert(type(color) == 'string')
    assert(type(label) == 'string')
    assert(type(position) == 'table')
    assert(type(rotation) == 'table')

    local token = _getByName('GoPiece', color)
    if token then
        local collide = false
        local fast = true
        token.setPositionSmooth(position, collide, fast)
        token.setRotationSmooth(rotation, collide, fast)
    else
        local bag = SeatTokens._getBag()
        for _, entry in ipairs(bag.getObjects()) do
            if entry.name == color then
                token = bag.takeObject({
                    position          = position,
                    rotation          = rotation,
                    smooth            = true,
                    guid              = entry.guid
                })
            end
        end
    end
    if not token then
        error('SeatTokens.moveToken: missing token "' .. color .. '"')
    end
    token.setScale({ x = 2.5, y = 0.5, z = 2.5 })
    if label then
        token.clearButtons()
        token.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = label,
            position       = { x = 0, y = 0.19, z = 0 },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1, y = 1, z = 1 },
            width          = 0,
            height         = 0,
            font_size      = 80,
            font_color     = { r = 0, g = 0, b = 0 }
        })
    end
    return token
end

function SeatTokens.getAll()
    local nameSet = {}
    for _, color in ipairs(_zoneHelper.zones()) do
        nameSet[color] = true
    end
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'GoPiece' and nameSet[object.getName()] then
            table.insert(result, object)
        end
    end
    return result
end

function SeatTokens.stow()
    local bag = SeatTokens._getBag()
    for _, object in ipairs(SeatTokens.getAll()) do
        object.clearButtons()
        bag.putObject(object)
    end
end

-------------------------------------------------------------------------------

FactionTokens = {
    BAG_NAME = 'Pick a Faction to Play',
    _bagGuid = false
}

function FactionTokens._getBag()
    local bag = FactionTokens._bagGuid and getObjectFromGUID(FactionTokens._bagGuid)
    if bag then
        return bag
    end
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Bag' and object.getName() == FactionTokens.BAG_NAME then
            FactionTokens._bagGuid = object.getGUID()
            return object
        end
    end
    error('FactionTokens._getBag: missing "' .. FactionTokens.BAG_NAME .. '"')
end

function FactionTokens.shuffle()
    local bag = FactionTokens._getBag()
    bag.shuffle()
end

function FactionTokens.placeRandomToken(position, rotation)
    local bag = FactionTokens._getBag()
    local token = bag.takeObject({
        position          = position,
        rotation          = rotation,
        smooth            = true,
    })
    return token
end

function FactionTokens.getAll()
    local nameSet = {}
    for _, faction in pairs(_factionHelper.allFactions(true)) do
        nameSet[faction.tokenName .. ' Faction Token'] = true
    end
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Card' and nameSet[object.getName()] then
            table.insert(result, object)
        end
    end
    return result
end

function FactionTokens.stow()
    local bag = FactionTokens._getBag()
    for _, object in ipairs(FactionTokens.getAll()) do
        bag.putObject(object)
    end
end

-------------------------------------------------------------------------------

SystemTiles = {
    _tileGuidToBagGuid = false
}

function SystemTiles.getRedTiles()
    local isPoK = _setupHelper.getPoK()
    local result = {}
    for _, system in pairs(_systemHelper.systems()) do
        local isRedTile = false
        isRedTile = isRedTile or (system.anomalies and #system.anomalies > 0)
        isRedTile = isRedTile or (not system.planets) or (#system.planets == 0)
        if system.tile > 91 then
            isRedTile = false
        end
        if system.tile > 51 and not isPoK then
            isRedTile = false
        end
        if system.hyperlane then
            isRedTile = false
        end
        if system.home then
            isRedTile = false
        end
        if system.tile == 81 then
            isRedTile = false  -- Muaat supernova
        end
        if isRedTile then
            table.insert(result, system.tile)
        end
    end
    return result
end

function SystemTiles._getTileBag(tileGuid)
    assert(type(tileGuid) == 'string')
    if not SystemTiles._tileGuidToBagGuid then
        SystemTiles._tileGuidToBagGuid = {}
        local guidToSystem = _systemHelper.systems()
        local bagSet = {
            ['Blue Planet Tiles'] = true,
            ['Red Anomaly Tiles'] = true,
        }
        local tileToBag = {}
        for _, object in ipairs(getAllObjects()) do
            if object.tag == 'Bag' and bagSet[object.getName()] then
                local bagGuid = object.getGUID()
                for _, entry in ipairs(object.getObjects()) do
                    if guidToSystem[entry.guid] then
                        SystemTiles._tileGuidToBagGuid[entry.guid] = bagGuid
                    end
                end
            end
        end
    end
    local bagGuid = SystemTiles._tileGuidToBagGuid[tileGuid]
    return bagGuid and getObjectFromGUID(bagGuid)
end

function SystemTiles.placeTile(tile, position, rotation)
    local system = _systemHelper.systemFromTile(tile)
    if not system then
        error('SystemTiles._placeTile: not such tile ' .. tile)
    end
    local bag = SystemTiles._getTileBag(system.guid)
    local tileObject = false
    if bag then
        tileObject = bag.takeObject({
            position          = position,
            rotation          = rotation,
            smooth            = true,
            guid              = system.guid
        })
    else
        tileObject = getObjectFromGUID(system.guid)
        if tileObject then
            local collide = false
            local fast = true
            tileObject.setPositionSmooth(position, collide, fast)
            tileObject.setRotationSmooth(rotation, collide, fast)
        end
    end
    if not tileObject then
        error('SystemTiles._placeTile: missing tile ' .. tile)
    end
    Wait.time(function() _systemHelper.lockSystemTile(system.guid) end, 3)
    return tileObject
end

function SystemTiles._getTileData(tileGuid)
    -- Find in bag (expected path).
    local bag = SystemTiles._getTileBag(tileGuid)
    if bag then
        for _, tileData in ipairs(bag.getData().ContainedObjects) do
            if tileData.GUID == tileGuid then
                return tileData
            end
        end
    end
    -- Not found in bag, look on table.
    local tileObject = getObjectFromGUID(tileGuid)
    if tileObject then
        return tileObject.getData()
    end
    error('SystemTiles._getTileData: missing tile ' .. tileGuid)
end

-------------------------------------------------------------------------------

Slice = {
    -- Slice is a mini-map string with tiles in this order.
    OFFSETS = {
        { name = 'leftOfHome', x = -1, z = 0.5 },
        { name = 'frontOfHome', x = 0, z = 1 },
        { name = 'rightOfHome', x = 1, z = 0.5 },
        { name = 'leftEquidistant', x = -1, z = 1.5 },
        { name = 'frontFurther', x = 0, z = 2 },
    }
}

--- Compute "R/I TECH LEGENDARY" label from a list of tile numbers.
function Slice.getLabel(tiles)
    local r = 0
    local i = 0
    local tech = {}
    local legendary = 0
    for _, tile in ipairs(tiles) do
        local system = _systemHelper.systemFromTile(tile)
        for _, planet in ipairs(system.planets or {}) do
            r = r + (planet.resources or 0)
            i = i + (planet.influence or 0)
            if planet.tech then
                table.insert(tech, string.sub(planet.tech, 1, 1):upper())
            end
            if planet.legendary then
                legendary = legendary + 1
            end
        end
    end
    local items = {
        r .. '/' .. i
    }
    if #tech > 0 then
        table.sort(tech)
        table.insert(items, table.concat(tech, ''))
    end
    if legendary > 0 then
        local n = legendary
        table.insert(items, ((n > 1) and n or '') .. 'L')
    end
    return table.concat(items, ' ')
end

--- Swap tiles so no anomalies are adjacent (in this slice).
function Slice.randomizeAndFixAdjacentAnomalies(tiles)
    local tiles = VolverMilty.permute(tiles)

    local anomalySet = {}
    for _, tile in ipairs(tiles) do
        local system = _systemHelper.systemFromTile(tile)
        if system.anomalies and #system.anomalies > 0 then
            anomalySet[tile] = true
        end
    end
    local nameToIndex = {}
    for i, offset in ipairs(Slice.OFFSETS) do
        nameToIndex[offset.name] = i
    end

    local swapRules = {
        {
            check1 = 'leftOfHome',
            check2 = 'leftEquidistant',
            swaps = {
                { 'leftOfHome', 'rightOfHome' },
                { 'leftEquidistant', 'rightOfHome' },
                { 'leftEquidistant', 'frontFurther' },
            },
        },
        {
            check1 = 'leftOfHome',
            check2 = 'frontOfHome',
            swaps = {
                { 'frontOfHome', 'frontFurther' },
                { 'frontOfHome', 'rightOfHome' },
            },
        },
        {
            check1 = 'frontOfHome',
            check2 = 'frontFurther',
            swaps = {
                { 'frontOfHome', 'leftOfHome' },
                { 'frontOfHome', 'rightOfHome' },
            },
        },
        {
            check1 = 'frontOfHome',
            check2 = 'leftEquidistant',
            swaps = {
                { 'frontOfHome', 'rightOfHome' },
            },
        },
        {
            check1 = 'frontOfHome',
            check2 = 'rightOfHome',
            swaps = {
                { 'frontOfHome', 'leftOfHome' },
                { 'frontOfHome', 'leftEquidistant' },
                { 'frontOfHome', 'frontFurther' },
            },
        },
        {
            check1 = 'leftEquidistant',
            check2 = 'frontFurther',
            swaps = {
                { 'leftEquidistant', 'leftOfHome' },
                { 'leftEquidistant', 'rightOfHome' },
                { 'frontFurther', 'rightOfHome' },
            },
        },
    }
    for _, swapRule in ipairs(swapRules) do
        local check1 = assert(tiles[nameToIndex[swapRule.check1]])
        local check2 = assert(tiles[nameToIndex[swapRule.check2]])
        if anomalySet[check1] and anomalySet[check2] then
            math.randomseed(os.time())
            local swap = assert(swapRule.swaps[math.random(1, #swapRule.swaps)])
            local index1 = assert(nameToIndex[swap[1]])
            local index2 = assert(nameToIndex[swap[2]])
            local tile1 = tiles[index1]
            local tile2 = tiles[index2]
            tiles[index1] = tile2
            tiles[index2] = tile1
        end
    end

    return tiles
end

--- Get position given the home system position and tile index.
-- Optionally apply slice rotation to account for map orientation.
function Slice._getTilePosition(i, p0, applyRotation)
    assert(type(i) == 'number', 'bad i')
    assert(type(p0) == 'table', 'bad p0')
    assert(type(applyRotation) == 'boolean', 'bad applyRotation')

    local offset = { x = 0, z = 0 }
    if i > 0 then
        offset = assert(Slice.OFFSETS[i])
    end

    local function getOutscribedTileRadius()
        local x = Grid.sizeX or 7
        local y = Grid.sizeY or 7
        assert(x == y, 'error: not a square grid')
        return x / 2.0
    end

    local function getInscribedTileRadius()
        local r = getOutscribedTileRadius()
        local c = r
        local b = r / 2.0
        return math.sqrt(c^2 - b^2)
    end

    -- Compute position.
    local dx = getInscribedTileRadius() * 2 * offset.x
    local dz = getInscribedTileRadius() * 2 * offset.z
    if applyRotation then
        local theta = math.atan2(p0.z, p0.x) - (math.pi / 2)
        local inverse = (theta + math.pi) % (math.pi * 2)
        local dx2 = math.cos(inverse) * dx - math.sin(inverse) * dz
        local dz2 = math.sin(inverse) * dx + math.cos(inverse) * dz
        dx, dz = dx2, dz2
    end
    local pos = {
        x = p0.x + dx,
        y = p0.y,
        z = p0.z + dz,
    }

    -- Convert to hex and back again to be certain pos is grid aligned.
    local y = pos.y
    local hex = _systemHelper.hexFromPosition(pos)
    pos = _systemHelper.hexToPosition(hex)
    pos = {
        x = pos.x,
        y = y,
        z = pos.z
    }

    return pos
end

--- Place system tiles, find tiles in bags or on table.
function Slice.placeTiles(tiles, homeSystemPosition, applyRotation)
    assert(type(tiles) == 'table')
    assert(type(homeSystemPosition) == 'table')
    assert(type(applyRotation) == 'boolean')

    for i, tile in ipairs(tiles) do
        local pos = Slice._getTilePosition(i, homeSystemPosition, applyRotation)
        local rot = { x = 0, y = 180, z = 0 }
        SystemTiles.placeTile(tile, pos, rot)
    end
end

-------------------------------------------------------------------------------

function _selectFaction(color, factionTokenName)
    assert(type(color) == 'string' and type(factionTokenName) == 'string')

    local factionSelector = false
    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()
        if name == 'Faction Selector' then
            local zone = _zoneHelper.zoneFromPosition(object.getPosition())
            if zone == color then
                factionSelector = object
                break
            end
        end
    end
    assert(factionSelector, 'missing faction selector for ' .. color)

    -- Requires a mod update for this to be available, fall through to the hack way.
    if factionSelector.getVar('selectFaction') then
        factionSelect.call('selectFaction', factionTokenName)
        return
    end

    -- From here to the end will be removed once the faction selector has the new method.
    -- The faction selector has its own faction ids, sigh.
    local FACTION_ID_AND_TOKEN_NAMES = {
        { id = 'Arborec', tokenName = 'Arborec' },
        { id = 'Letnev', tokenName = 'Barony of Letnev' },
        { id = 'Saar', tokenName = 'Clan of Saar' },
        { id = 'Muaat', tokenName = 'Embers of Muaat' },
        { id = 'Hacan', tokenName = 'Emirates of Hacan' },
        { id = 'Sol', tokenName = 'Federation of Sol' },
        { id = 'Creuss', tokenName = 'Ghosts of Creuss' },
        { id = 'L1Z1X', tokenName = 'L1Z1X Mindnet' },
        { id = 'Mentak', tokenName = 'Mentak Coalition' },
        { id = 'Naalu', tokenName = 'Naalu Collective' },
        { id = 'Nekro', tokenName = 'Nekro Virus' },
        { id = 'Sardakk', tokenName = "Sardakk N'orr", },
        { id = 'JolNar', tokenName = 'Universities of Jol-Nar' },
        { id = 'Winnu', tokenName = 'Winnu' },
        { id = 'Xxcha', tokenName = 'Xxcha Kingdom' },
        { id = 'Yin', tokenName = 'Yin Brotherhood' },
        { id = 'Yssaril', tokenName = 'Yssaril Tribes' },
        { id = 'Argent', tokenName = 'Argent Flight', pok = true },
        { id = 'Cabal', tokenName = "Vuil'raith Cabal", pok = true },
        { id = 'Empyrean', tokenName = 'Empyrean', pok = true },
        { id = 'Mahact', tokenName = 'Mahact Gene-Sorcerers', pok = true },
        { id = 'Nomad', tokenName = 'Nomad', pok = true },
        { id = 'NRA', tokenName = 'Naaz-Rokha Alliance', pok = true },
        { id = 'Titans', tokenName = 'Titans of Ul', pok = true },
    }
    local id = false
    for _, entry in ipairs(FACTION_ID_AND_TOKEN_NAMES) do
        if entry.tokenName == factionTokenName then
            id = entry.id
            break
        end
    end
    assert(id, 'missing id for "' .. factionTokenName .. '"')

    local clickFunction = 'selectFaction_' .. id
    factionSelector.call(clickFunction)
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)
