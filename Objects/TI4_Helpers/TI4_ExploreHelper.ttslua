-- @author Darrell for context menu stuff
-- @author Milty for adapting to exploration
-- #include <~/CrLua/Objects/TI4_Helpers/TI4_ExploreHelper>

local exploreCardToTokenMap = {
    ["Propulsion Research Facility"] = {"Propulsion Research Facility Token"}, -- 1r1i or blue
    ["Cybernetic Research Facility"] = {"Cybernetic Research Facility Token"}, -- 1r1i or yellow
    ["Biotic Research Facility"] = {"Biotic Research Facility Token"}, -- 1r1i or green
    ["Warfare Research Facility"] = {"Warfare Research Facility Token"}, -- 1r1i or red
    ["Lazax Survivors"] = {"Lazax Survivors Token"}, -- 1r2i
    ["Rich World"] = {"Rich World Token"}, -- 1r
    ["Mining World"] = {"Mining World Token"}, -- 2r
    ["Dyson Sphere"] = {"Dyson Sphere Token"}, -- 2r1i
    ["Paradise World"] = {"Paradise World Token"}, -- 2i
    ["Tomb of Emphidia"] = {"Tomb of Emphidia Token"}, -- 1i
    ["Demilitarized Zone (PoK)"] = {"DMZ Token"},
    ["Gamma Wormhole"] = {"Gamma Wormhole Token"},
    ["Gamma Relay"] = {"Gamma Wormhole Token"},
    ["Mirage (Exploration)"] = {"Mirage Token", "Mirage", "Mirage Flight Academy"},
    ["Ion Storm"] = {"Ion Storm Token"},
    ["Stellar Converter"] = {"Stellar Converter Token"},
}

local attachTokens = {
    ['Propulsion Research Facility Token'] = {
        decal = true,
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'blue' },
    },
    ['Cybernetic Research Facility Token'] = {
        decal = true,
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'yellow' },
    },
    ['Biotic Research Facility Token'] = {
        decal = true,
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'green' },
    },
    ['Warfare Research Facility Token'] = {
        decal = true,
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'red' },
    },
    ['Lazax Survivors Token'] = {
        decal = true,
        faceUpOrDown = { resources = 1, influence = 2 },
    },
    ['Rich World Token'] = {
        decal = true,
        faceUpOrDown = { resources = 1 },
    },
    ['Mining World Token'] = {
        decal = true,
        faceUpOrDown = { resources = 2 },
    },
    ['Dyson Sphere Token'] = {
        decal = true,
        faceUpOrDown = { resources = 2, influence = 1 },
    },
    ['Paradise World Token'] = {
        decal = true,
        faceUpOrDown = { influence = 2 },
    },
    ['Tomb of Emphidia Token'] = {
        decal = true,
        faceUpOrDown = { influence = 1 },
    },
    ['DMZ Token'] = {
        decal = true,
        faceUpOrDown = {},
    },
    ['Titan Note Token'] = {
        decal = true,
        faceUpOrDown = { resources = 1, influence = 1 },  -- need multi-trait support for rest
    },
    ['Titan Ultimate Token'] = {
        decal = true,
        faceUpOrDown = { resources = 3, influence = 3 },
    },
    ['Tear Token (Cabal)'] = {
        noanchor = true,
        injectFunction = function (system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Tear Token (Cabal)')
            return _tearTokenInjectFunction(system, planetName, attachTokenObject)
        end,
        ejectFunction = function(system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Tear Token (Cabal)')
            return _tearTokenEjectFunction(system, planetName, attachTokenObject)
        end
    },
    ['Tear Token (Nekro)'] = {
        noanchor = true,
        injectFunction = function (system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Tear Token (Nekro)')
            return _tearTokenInjectFunction(system, planetName, attachTokenObject)
        end,
        ejectFunction = function(system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Tear Token (Nekro)')
            return _tearTokenEjectFunction(system, planetName, attachTokenObject)
        end
    },
    ['Mirage Token'] = {
        systemModifer = true, -- System modifiers get loaded before planet modifiers
        injectFunction = function (system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Mirage Token')
            return _mirageTokenInjectFunction(system, planetName, attachTokenObject)
        end,
        ejectFunction = function(system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Mirage Token')
            return _mirageTokenEjectFunction(system, planetName, attachTokenObject)
        end
    },
    ['Stellar Converter Token'] = {
        noanchor = true,
        injectFunction = function (system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Stellar Converter Token')
            return _stellarConverterTokenInjectFunction(system, planetName, attachTokenObject)
        end,
        ejectFunction = function(system, planetName, attachTokenObject)
            assert(attachTokenObject.getName() == 'Stellar Converter Token')
            return _stellarConverterTokenEjectFunction(system, planetName, attachTokenObject)
        end
    },
}

local MIRAGE_PLANET = {
    name = 'Mirage',
    resources = 1,
    influence = 2,
    trait = 'cultural',
    legendary = true,
    legendaryCard = 'Mirage Flight Acadamy'
}

-------------------------------------------------------------------------------

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _deckHelper = getHelperClient('TI4_DECK_HELPER')
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')

local function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

-------------------------------------------------------------------------------

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_EXPLORE_HELPER')
    self.setDescription('Adds right-click exploration options to system tiles and frontier tokens, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    local function delayedAdd()
        local attachObjectGuids = {}
        local attachObjectSystemModifierGuids = {}
        local lowerPlanetNameSet = _systemHelper.planets()

        for _, object in ipairs(getAllObjects()) do
            if isExplorable(object) then
                applyExplorationGoodness(object)
            elseif isFrontierToken(object) then
                applyFrontierGoodness(object)
            elseif object.tag == 'Card' and lowerPlanetNameSet[string.lower(object.getName())] then
                -- Will re-add during attach below
                object.setDecals({})
            end

            if AttachLib.isAttachToken(object) then
                if AttachLib.isSystemModifierAttachToken(object) then
                    table.insert(attachObjectSystemModifierGuids, object.getGUID())
                else
                    table.insert(attachObjectGuids, object.getGUID())
                end
            end
        end

        -- These are more expensive, spread them out.
        local function attachOnePerFrame()
            local guid = table.remove(attachObjectSystemModifierGuids)
            if not guid then
                guid = table.remove(attachObjectGuids)
            end
            local object = getObjectFromGUID(guid)
            if object then
                AttachLib.attach(object, false)
            end
            if #attachObjectSystemModifierGuids > 0 or #attachObjectGuids > 0 then
                Wait.frames(attachOnePerFrame, 1)
            end
        end
        Wait.frames(attachOnePerFrame, 1)
    end

    Wait.frames(delayedAdd, 11)
end

function onObjectSpawn(object)
    if isExplorable(object) then
        applyExplorationGoodness(object)
    elseif isFrontierToken(object) then
        applyFrontierGoodness(object)
    elseif AttachLib.isAttachToken(object) then
        AttachLib.attach(object, true)
    end

    -- Give token when card is drawn.
    if object.tag == 'Card' and object.getName() == 'Stellar Converter' then
        local guid = object.guid
        local function delayedCheck()
            local object = getObjectFromGUID(guid)
            if object then
                checkCardForToken(object, false, false)
            end
        end
        Wait.time(delayedCheck, 5)
    end
end

function onObjectDrop(playerColor, droppedObject)
    if AttachLib.isAttachToken(droppedObject) then
        if AttachLib.attach(droppedObject, true) then
            AttachLib.anchor(droppedObject)  -- move beneath any units and lock
        end
    end
end

function onObjectPickUp(playerColor, pickupObject)
    if AttachLib.isAttachToken(pickupObject) then
        AttachLib.detach(pickupObject)
    end
end

-------------------------------------------------------------------------------

function applyExplorationGoodness(object)
    assert(type(object) == 'userdata')
    if object.getName() == 'Mirage Token' then
        local function exploreMirage()
            -- System tile has correct data when Mirage dropped there, but
            -- since Mirage can move re-find system when asked to explore.
            local system = _systemHelper.systemFromPosition(object.getPosition())
            if system then
                explorePlanet(system.guid, 'Mirage')
            else
                printToAll('Mirage not attached to a system, cannot explore', 'Red')
            end
        end
        object.addContextMenuItem('Explore Mirage', exploreMirage, false)
    else
        local systemList = _systemHelper.systems()
        local planetList = systemList[object.getGUID()].planets
        if planetList ~= nil then
            for i, planet in ipairs(planetList) do
                if planet.trait ~= nil then
                    object.addContextMenuItem('Explore ' .. planet.name, function() explorePlanet(object.getGUID(), planet.name) end, false)
                end
            end
        end
    end
end

function applyFrontierGoodness(object)
    assert(type(object) == 'userdata')
    object.addContextMenuItem('Explore Frontier', function() exploreFrontier(object) end, false)
end

function explorePlanet(tileGUID, planetName)
    local systemList = _systemHelper.systems()
    local planetTrait = false
    local deckType = false
    local tile = false
    local tilePos = false
    local planetPos = false
    local tileRot = false

    local traitMap = {
        ['cultural'] = 'Cultural Exploration',
        ['hazardous'] = 'Hazardous Exploration',
        ['industrial'] = 'Industrial Exploration'
    }

    for i, planet in ipairs(systemList[tileGUID].planets) do
        if planet.name == planetName then
            planetTrait = planet.trait
            planetPos = planet.position
        end
    end
    assert(planetTrait)

    deckType = traitMap[planetTrait]

    local tile = assert(getObjectFromGUID(tileGUID))
    local tilePos = tile.getPosition()
    local tileRot = tile.getRotation()

    local exploreDeckGuid = _deckHelper.getDeckWithReshuffle(deckType)
    if not exploreDeckGuid then
        printToAll('ERROR: Unable to locate ' .. deckType .. ' deck.', 'Red')
        return
    end
    local exploreDeck = assert(getObjectFromGUID(exploreDeckGuid))

    local position = tile.positionToWorld(planetPos)
    position.y = position.y + 3
    local rotation = { x = 0, y = tileRot.y, z = 0 }

    if exploreDeck.tag == 'Deck' then
        exploreDeck.takeObject({
          position = position,
          rotation = rotation,
          callback_function = function(obj) checkCardForToken(obj, tileGUID, planetName) end,
          smooth = true
        })
    elseif exploreDeck.tag == 'Card' then
        local collide = false
        local fast = true
        exploreDeck.setPositionSmooth(position, collide, fast)
        exploreDeck.setRotationSmooth(rotation, collide, fast)
    else
        error('exploreFrontier: bad "' .. deckType .. '" deck')
    end
    broadcastToAll('Exploring Planet: ' .. planetName)
end

function exploreFrontier(token)
    assert(type(token) == 'userdata')

    local tokenPos = token.getPosition()
    local tokenRot = token.getRotation()

    local frontierDeckGuid = _deckHelper.getDeckWithReshuffle('Frontier Exploration')
    if not frontierDeckGuid then
        printToAll('ERROR: Unable to locate "Frontier Exploration" deck.', 'Red')
        return
    end
    local frontierDeck = assert(getObjectFromGUID(frontierDeckGuid))

    local position = { x = tokenPos.x, y = tokenPos.y + 3, z = tokenPos.z }
    local rotation = { x = 0, y = 0, z = 0 }
    local system = _systemHelper.systemFromPosition(tokenPos)
    local systemObject = system and getObjectFromGUID(system.guid)
    if systemObject then
        rotation.y = systemObject.getRotation().y
    end

    if frontierDeck.tag == 'Deck' then
        frontierDeck.takeObject({
            position = position,
            rotation = rotation,
            callback_function = function(obj) checkCardForToken(obj, '', false) end,
            smooth = true
        })
    elseif frontierDeck.tag == 'Card' then
        local collide = false
        local fast = true
        frontierDeck.setPositionSmooth(position, collide, fast)
        frontierDeck.setRotationSmooth(rotation, collide, fast)
    else
        error('exploreFrontier: bad "Frontier Exploration" deck')
    end

    local frontierTokenBag = assert(_getByName('Frontier Tokens Bag', 'Infinite'))
    frontierTokenBag.putObject(token)

    broadcastToAll('Exploring Frontier Token')
end

function checkCardForToken(object_spawned, tileGUID, planetName)
    local cardName = object_spawned.getName()
    local tokensToRetrieveSet = {}
    for _, item in ipairs(exploreCardToTokenMap[cardName] or {}) do
        tokensToRetrieveSet[item] = true
    end

    local explorationBag = _getByName('Exploration Bag', 'Bag')
    for i, token in ipairs(explorationBag.getObjects()) do
        if tokensToRetrieveSet[token.name] then

            local position = object_spawned.getPosition()
            position.y = position.y + i * 0.3
            local rotation = object_spawned.getRotation()

            local function takeCallback(object)
                if AttachLib.isAttachToken(object) then
                    -- Attach will figure out if token should be face up/down.
                    if AttachLib.attach(object, true) then
                        AttachLib.anchor(object)  -- move beneath any units and lock
                    end
                end
            end

            explorationBag.takeObject({
                position = position,
                rotation = rotation,
                guid = token.guid,
                smooth = true,
                callback_function = takeCallback
            })

            -- Only get each token once.
            tokensToRetrieveSet[token.name] = nil
        end
    end
end

-------------------------------------------------------------------------------

local _systemGuids = false
function isExplorable(object)
    if not _systemGuids then
        _systemGuids = {}
        for guid, _ in pairs(_systemHelper.systems()) do
            _systemGuids[guid] = true
        end
    end
    if object.tag ~= 'Generic' then
        return false
    end
    if _systemGuids[object.getGUID()] then
        return true
    end
    if object.getName() == 'Mirage Token' then
        return true
    end
end

function isFrontierToken(object)
    return object.tag == 'Generic' and object.getName() == 'Frontier Token'
end

function getAllFrontierTokens()
    local frontierTokens = {}

    for _, object in ipairs(getAllObjects()) do
        if isFrontierToken(object) then
            table.insert(frontierTokens, object)
        end
    end

    return frontierTokens
end

local _getByNameCache = {}
function _getByName(name, tag)
    local guid = _getByNameCache[name]
    local object = guid and getObjectFromGUID(guid)
    if object and ((not tag) or object.tag == tag) then
        return object
    end
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == name and ((not tag) or object.tag == tag) then
            _getByNameCache[name] = object.getGUID()
            return object
        end
    end
    error('_getByName: missing "' .. name .. '"')
end

-------------------------------------------------------------------------------

-- Default position is slightly right of center
local DEFAULT_FRONTIER_TOKEN_POSITION = { x = -1, y = 0, z = 0 }

function systemShouldGetFrontierToken(system)
    if system.planets and #system.planets > 0 then
        return false
    end
    if system.hyperlane == true then
        return false
    end

    return true
end

function _placeFrontierTokensCoroutine()
    local frontierTokenBag = assert(_getByName('Frontier Tokens Bag'))

    local guidToSystem = _systemHelper.systems()
    local emptySystemGuidToTokenPositions = {}
    local emptySystemGuidToPosition = {}
    local frontierTokenObjectsToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local system = guidToSystem[object.getGUID()]
        -- Collect all system tiles that are 'empty', along with the position a frontier token would go
        if system and systemShouldGetFrontierToken(system) then
            local tokenPosition = object.positionToWorld(DEFAULT_FRONTIER_TOKEN_POSITION)
            emptySystemGuidToPosition[object.getGUID()] = object.getPosition()
            emptySystemGuidToTokenPositions[object.getGUID()] = tokenPosition
        -- Collect all current frontier token positions
        elseif isFrontierToken(object) then
            frontierTokenObjectsToPosition[object.getGUID()] = object.getPosition()
        end
    end
    coroutine.yield(0)

    -- Find set of hex coordinates containing frontier tokens
    local frontierTokenGuidToHex = _systemHelper.hexesFromPositions(frontierTokenObjectsToPosition)
    local hexesWithFrontierTokens = {}
    for _, hex in pairs(frontierTokenGuidToHex) do
        hexesWithFrontierTokens[hex] = true
    end

    -- Empty systems to hex coordinates
    local emptySystemGuidToHex = _systemHelper.hexesFromPositions(emptySystemGuidToPosition)

    -- For each empty system, if it's hex coordinate doesn't have a frontier token then place a new one.
    for systemGuid, tokenPosition in pairs(emptySystemGuidToTokenPositions) do
        if emptySystemGuidToHex[systemGuid] and not hexesWithFrontierTokens[emptySystemGuidToHex[systemGuid]] then
            frontierTokenBag.takeObject({
                position = { x = tokenPosition.x, y = tokenPosition.y + 3, z = tokenPosition.z },
                smooth   = true,
            })
            coroutine.yield(0)
        end
    end

    return 1
end

function placeFrontierTokens()
    startLuaCoroutine(self, '_placeFrontierTokensCoroutine')
end

function retrieveFrontierTokens()
    local frontierTokenBag = assert(_getByName('Frontier Tokens Bag'))

    -- Grab all frontier tokens, from everywhere.
    for _, object in ipairs(getAllObjects()) do
        if isFrontierToken(object) then
            frontierTokenBag.putObject(object)
        end
    end
end

-------------------------------------------------------------------------------

AttachLib = {}

function AttachLib.isAttachToken(object)
    assert(type(object) == 'userdata')
    return attachTokens[object.getName()] and true or false
end

function AttachLib.isSystemModifierAttachToken(object)
    assert(type(object) == 'userdata')
    return (attachTokens[object.getName()] and attachTokens[object.getName()].systemModifer) and true or false
end

--- Attach token to system, return true on success.
function AttachLib.attach(attachTokenObject, setOrientation)
    assert(type(attachTokenObject) == 'userdata')
    local system, planetName = AttachLib._getSystemAndPlanetName(attachTokenObject.getPosition())
    if system then
        if setOrientation then
            AttachLib._orientToken(system, planetName, attachTokenObject)
        end
        local success = AttachLib._injectAttachment(system, planetName, attachTokenObject)
        if success then
            if attachTokens[attachTokenObject.getName()].decal then
                local card = AttachLib._getPlanetCard(planetName)
                if card then
                    AttachLib._attachDecal(card, attachTokenObject)
                end
            end
            local name = planetName or system.string
            printToAll('Attaching "' .. attachTokenObject.getName() .. '" to "' .. name .. '"', 'Yellow')
            return true
        end
    end
end

--- Detach token from system, return true on success.
function AttachLib.detach(attachTokenObject)
    assert(type(attachTokenObject) == 'userdata')
    local system, planetName = AttachLib._getSystemAndPlanetName(attachTokenObject.getPosition())
    if system then
        local success = AttachLib._ejectAttachment(system, planetName, attachTokenObject)
        if success then
            if attachTokens[attachTokenObject.getName()].decal then
                local card = AttachLib._getPlanetCard(planetName)
                if card then
                    AttachLib._detachDecal(card, attachTokenObject)
                end
            end
            local name = planetName or system.string
            printToAll('Detaching "' .. attachTokenObject.getName() .. '" from "' .. name .. '"', 'Yellow')
            return true
        end
    end
end

--- Move beneath any units and lock.
function AttachLib.anchor(attachTokenObject)
    assert(type(attachTokenObject) == 'userdata')

    local attachmentAttrs = assert(attachTokens[attachTokenObject.getName()])
    if attachmentAttrs.noanchor then
        return
    end

    local system, planetName = AttachLib._getSystemAndPlanetName(attachTokenObject.getPosition())

    local systemObject = system and getObjectFromGUID(system.guid)
    if not systemObject then
        return
    end

    local position = systemObject.getPosition()
    position.y = position.y + system.y + 0.5

    -- If there is a planet, use planet position instead.
    if planetName then
        attachTokenObject.setLock(false)

        for _, planet in ipairs(system.planets or {}) do
            if planet.name == planetName then
                position = planet.position

                -- Offset in local space when multiple attachments.
                local slot = false
                for name, attachment in pairs(planet._attachments or {}) do
                    if name == attachTokenObject.getName() then
                        slot = attachment.slot
                    end
                end
                if slot then
                    if slot > 5 then
                        slot = slot + 0.5
                    end
                    local phi = math.rad((slot * 360 / 5) - 52)
                    local r = 0.52
                    position = {
                        x = position.x + math.cos(phi) * r,
                        y = position.y,
                        z = position.z + math.sin(phi) * r
                    }
                end

                -- Convert to world space for placement.
                position = systemObject.positionToWorld(position)
                position.y = position.y + system.y + 0.5
                break
            end
        end
    end

    assert(position)
    local collide = false
    local fast = true
    attachTokenObject.setPositionSmooth(position, collide, fast)

    -- Lock (after things are stable).
    local function condition()
        if attachTokenObject.isSmoothMoving() then
            return false
        end
        if not attachTokenObject.resting then
            return false
        end
        return true
    end
    local function action()
        attachTokenObject.setLock(true)
    end
    local function timeout() end
    Wait.condition(action, condition, 3, timeout)
end

function AttachLib._getSystemAndPlanetName(position)
    assert(type(position) == 'table')
    local system = _systemHelper.systemFromPosition(position)
    local planet = system and _systemHelper.planetFromPosition({
        systemGuid = system.guid,
        position = position,
        exact = false
    })
    local card = false
    if planet then
        -- Do NOT cache planet cards by guid, deck helper may change guids.
        for _, object in ipairs(getAllObjects()) do
            if object.tag == 'Card' and object.getName() == planet.name then
                card = object
                break
            end
        end
    end
    return system, (planet and planet.name), card
end

-- Tech ALWAYS applies unless the planet already has one (can be any).
function AttachLib._orientToken(system, planetName, attachTokenObject)
    assert(type(system) == 'table' and (not planetName or type(planetName) == 'string') and type(attachTokenObject) == 'userdata')

    local name = attachTokenObject.getName()
    local attrs = assert(attachTokens[name])
    if attrs.noanchor then
        return
    end

    local planetHasAnyTech = false
    for _, planet in ipairs(system.planets or {}) do
        if planet.name == planetName then
            planetHasAnyTech = planet.tech ~= nil
            break
        end
    end

    local systemObject = assert(getObjectFromGUID(system.guid))
    local rotation = systemObject.getRotation()
    rotation.z = (planetHasAnyTech and 0) or 180

    attachTokenObject.setRotation(rotation)
end

--- Add attachment to a system's planet entry.
function AttachLib._injectAttachment(system, planetName, attachTokenObject)
    assert(type(system) == 'table' and (not planetName or type(planetName) == 'string') and type(attachTokenObject) == 'userdata')

    system = copyTable(system)
    local name = attachTokenObject.getName()
    local attrs = assert(attachTokens[name])

    -- Override standard injection?
    if attrs.injectFunction then
        system = attrs.injectFunction(system, planetName, attachTokenObject)
        if system then
            _systemHelper.injectSystem(system)
        end
        return system and true or false
    end

    -- Otherwise MUST have a planet.
    if not planetName then
        return false
    end

    local attachment = false
    -- Object.is_face_down might be wrong if rotation was changed this frame.
    -- Read rotation instead.
    local rotZ = attachTokenObject.getRotation().z
    if rotZ > 90 or rotZ < -90 then
        attachment = attrs.faceDown or attrs.faceUpOrDown
    else
        attachment = attrs.faceUp or attrs.faceUpOrDown
    end
    assert(attachment)

    local planet = false
    for _, candidate in ipairs(system.planets or {}) do
        if candidate.name == planetName then
            planet = candidate
            break
        end
    end
    assert(planet, 'missing planet ' .. name)
    if not planet._attachments then
        planet._attachments = {}
    end

    -- Remove if already present.
    local dele = planet._attachments[name]
    if dele then
        planet.resources = (planet.resources or 0) - (dele.resources or 0)
        planet.influence = (planet.influence or 0) - (dele.influence or 0)
        if dele.tech then
            planet.tech = nil
        end
        planet._attachments[name] = nil
    end

    -- Assign a slot (for positioning).  If a middle entry gets removed it
    -- might lead to incorrect positions after a save/load.  Let it slide.
    attachment = copyTable(attachment)
    local takenSet = {}
    for _, current in pairs(planet._attachments) do
        if current.slot then
            takenSet[current.slot] = true
        end
    end
    for i = 1, 100 do
        if not takenSet[i] then
            attachment.slot = i
            break
        end
    end
    assert(attachment.slot)

    -- Attach.
    planet._attachments[name] = attachment
    planet.resources = (planet.resources or 0) + (attachment.resources or 0)
    planet.influence = (planet.influence or 0) + (attachment.influence or 0)
    if attachment.tech then
        assert(not planet.tech)
        planet.tech = attachment.tech
    end

    if planet.resources <= 0 then
        planet.resources = nil
    end
    if planet.influence <= 0 then
        planet.influence = nil
    end

    _systemHelper.injectSystem(system)
    return true
end

-- Remove attachment from a system's planet entry.  DO NOT USE CURRENT ORIENTATION,
-- token may have flipped, instead remove by name.
function AttachLib._ejectAttachment(system, planetName, attachTokenObject)
    assert(type(system) == 'table' and (not planetName or type(planetName) == 'string') and type(attachTokenObject) == 'userdata')
    local name = attachTokenObject.getName()

    system = copyTable(system)
    local name = attachTokenObject.getName()
    local attrs = assert(attachTokens[name])

    -- Override standard ejection?
    if attrs.ejectFunction then
        system = attrs.ejectFunction(system, planetName, attachTokenObject)
        if system then
            _systemHelper.injectSystem(system)
        end
        return system and true or false
    end
    -- Otherwise MUST have a planet.
    if not planetName then
        return false
    end

    local planet = false
    for _, candidate in ipairs(system.planets or {}) do
        if candidate.name == planetName then
            planet = candidate
            break
        end
    end
    assert(planet, 'missing planet ' .. name)
    if not planet._attachments then
        planet._attachments = {}
    end

    local dele = planet._attachments[name]
    if dele then
        planet.resources = (planet.resources or 0) - (dele.resources or 0)
        planet.influence = (planet.influence or 0) - (dele.influence or 0)
        if dele.tech then
            planet.tech = nil
        end
        planet._attachments[name] = nil
    end

    _systemHelper.injectSystem(system)
    return true
end

--- Find the card object.
function AttachLib._getPlanetCard(planetName)
    assert(type(planetName) == 'string')
    -- Do NOT cache planet cards by guid, deck helper may change guids.
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Card' and object.getName() == planetName then
            return object
        end
    end
end

--- Add a decal to the planet card, with layout.
function AttachLib._attachDecal(planetCardObject, attachTokenObject)
    assert(type(planetCardObject) == 'userdata' and planetCardObject.tag == 'Card')
    assert(type(attachTokenObject) == 'userdata')
    local decalImage = false

    -- Object.is_face_down might be wrong if rotation was changed this frame.
    -- Read rotation instead.
    local rotZ = attachTokenObject.getRotation().z
    if rotZ > 90 or rotZ < -90 then
        decalImage = attachTokenObject.getCustomObject().image_bottom
    else
        decalImage = attachTokenObject.getCustomObject().image
    end
    if not decalImage then
        return  -- wrong object type with a different custom table?
    end
    local name = attachTokenObject.getName()
    local decals = planetCardObject.getDecals() or {}

    -- Remove if already present.
    for i, decal in ipairs(decals) do
        if decal.name == name then
            table.remove(decals, i)
        end
    end

    -- Add decal.
    local scale = { x = 0.6, y = 0.6, z = 1 } -- scale is literal size here
    table.insert(decals, {
        name = name,
        url = decalImage,
        position = { x = 0, y = 0.4, z = 0 },
        rotation = { x = 90, y = 180, z = 0 },
        scale = scale,
    })
    table.insert(decals, {
        name = name,
        url = decalImage,
        position = { x = 0, y = -0.4, z = 0 },
        rotation = { x = 270, y = 0, z = 0 },
        scale = scale,
    })
    AttachLib._layoutDecals(decals)
    planetCardObject.setDecals(decals)
end

--- Remove a decal from the planet card, with layout.
function AttachLib._detachDecal(planetCardObject, attachTokenObject)
    assert(type(planetCardObject) == 'userdata' and planetCardObject.tag == 'Card')
    assert(type(attachTokenObject) == 'userdata')
    local name = attachTokenObject.getName()
    local decals = planetCardObject.getDecals() or {}
    for i = #decals, 1, -1 do
        local decal = decals[i]
        if decal.name == name then
            table.remove(decals, i)
        end
    end
    AttachLib._layoutDecals(decals)
    planetCardObject.setDecals(decals)
end

--- Organize tokens for a grid layout, avoid planet res/inf and name areas.
function AttachLib._layoutDecals(decals)
    assert(type(decals) == 'table')
    local nextIndex = 0
    local nameToZeroBasedIndex = {}
    for _, decal in ipairs(decals) do
        if not nameToZeroBasedIndex[decal.name] then
            nameToZeroBasedIndex[decal.name] = nextIndex
            nextIndex = nextIndex + 1
        end
    end
    local x0 = 0.33
    local z0 = -1.1
    local dx = -0.66
    local dz = 0.65
    local numCols = 2
    for _, decal in ipairs(decals) do
        local zi = nameToZeroBasedIndex[decal.name]
        local row = math.floor(zi / numCols)
        local col = zi % numCols
        if row > 1 then
            row = row + 1.5 -- planet name area
        end
        decal.position = {
            x = x0 + dx * col,
            y = decal.position.y,
            z = z0 + dz * row
        }
        if decal.position.y < 0 then
            decal.position.x = -decal.position.x
        end
    end
end

-------------------------------------------------------------------------------

function _tearTokenInjectFunction(system, planetName, attachTokenObject)
    assert(system)
            
    if not planetName then
        printToAll(attachTokenObject.getName() .. ' should be placed on a planet.', 'Yellow')
        return false
    end

    -- Get planet attributes
    local planet = false
    for _, systemPlanet in ipairs(system.planets or {}) do
        if systemPlanet.name == planetName then
            planet = systemPlanet
            break
        end
    end
    assert(planet)

    -- If not set already, store original system stats
    if not system._baseAnomalies then
        system._baseAnomalies = copyTable(system.anomalies or {})
    end

    -- Add attachment to planet
    local attachment = { anomalies = { 'gravity rift' } }
    planet._attachments = planet._attachments or {}
    planet._attachments[attachTokenObject.getName()] = attachment

    -- Does system already have a gravity rift?
    local existingAnomaliesSet = {}
    for _, anomaly in ipairs(system.anomalies or {}) do
        existingAnomaliesSet[anomaly] = true
    end

    -- If so, no need for further action.
    if existingAnomaliesSet['gravity rift'] then
        return system
    end

    -- Add gravity rift to system
    system.anomalies = system.anomalies or {}
    table.insert(system.anomalies, 'gravity rift')

    -- Notify players
    printToAll(system.string .. ' now has a gravity rift.', 'Yellow')

    -- Return updated system
    return system
end

function _tearTokenEjectFunction(system, planetName, attachTokenObject)
    assert(system)

    if not planetName then
        -- Just removing a token from a random system tile. Ignore.
        return false
    end

    if not system._baseAnomalies then
        -- There is no pre-attachment state, so nothing to return to. Error? Nah.
        return false
    end

    -- Get planet attributes
    local planet = false
    for _, systemPlanet in ipairs(system.planets or {}) do
        if systemPlanet.name == planetName then
            planet = systemPlanet
            break
        end
    end
    assert(planet)

    -- Check for attachment to remove
    local attachments = planet._attachments or {}
    if not attachments[attachTokenObject.getName()] then
        -- Attachment was never injected onto planet. Silent early exit.
        return false
    end

    -- Remove anomaly entry from planet
    planet._attachments[attachTokenObject.getName()] = nil

    -- Rebuild system anomalies, which may or may not have changed
    local fullAnomalySet = {}
    for _, anomaly in ipairs(system._baseAnomalies) do
        fullAnomalySet[anomaly] = true
    end
    for _, planet in ipairs(system.planets or {}) do
        for name, attachment in pairs(planet._attachments or {}) do
            for _, anomaly in ipairs(attachment.anomalies or {}) do
                fullAnomalySet[anomaly] = true
            end
        end
    end
    system.anomalies = nil -- Can only have non-empty values
    for anomaly, _ in pairs(fullAnomalySet) do
        system.anomalies = system.anomalies or {}
        table.insert(system.anomalies, anomaly)
    end

    if not fullAnomalySet['gravity rift'] then
        -- Notify players
        printToAll(system.string .. ' lost its gravity rift.', 'Yellow')
    end

    -- Return updated system
    return system
end

function _mirageTokenInjectFunction(system, planetName, attachTokenObject)
    if not system then
        return false
    end

    if system.planets and #system.planets > 0 then
        printToAll('Cannot attach ' .. attachTokenObject.getName() .. ' to a system with planets', 'Yellow')
        return false
    end

    -- Add planet to system.
    system.planets = system.planets or {}
    table.insert(system.planets, MIRAGE_PLANET)

    return system
end

function _mirageTokenEjectFunction(system, planetName, attachTokenObject)
    if not system then
        return false
    end

    -- Remove planet from system.
    local foundPlanet = false
    for i, planet in ipairs(system.planets or {}) do
        if planet.name == MIRAGE_PLANET.name then
            foundPlanet = true
            table.remove(system.planets, i)
            if #system.planets == 0 then
                system.planets = nil
            end
            
            return system
        end
    end
    
    return false
end

local _stellarConveterTokenDestroyPlanetQueue = {}
function _stellarConveterTokenDestroyPlanet_coroutine()
    local params = assert(table.remove(_stellarConveterTokenDestroyPlanetQueue))
    local system = assert(params.system)
    local planetName = assert(params.planetName)
    local attachToken = assert(params.attachToken)

    local systemObject = assert(getObjectFromGUID(system.guid))
    local attachTokenObject = assert(getObjectFromGUID(attachToken))

    if system._stellarConverterPlanet then
        -- If there is some evidence of a previous stellar converter action,
        -- which wasn't undone by detach, we should assume we're in a buggy state
        -- and noop. Players can do this manually.
        return 1
    end

    local planet = false
    for _, systemPlanet in ipairs(system.planets or {}) do
        if planetName == systemPlanet.name then
            planet = systemPlanet
            break
        end
    end
    assert(planet)

    -- Save planet state (planet card name, current attachment tokens+cards)
    system._stellarConverterPlanet = copyTable(planet)

    -- Get set of attachment tokens to search for
    local attachmentCardByToken = {}
    for card, tokens in pairs(exploreCardToTokenMap) do
        for _, tokenName in ipairs(tokens or {}) do
            if tokenName ~= 'Mirage Token' and tokenName ~= 'Stellar Converter Token' then -- Stellar Converter doesn't remove Mirage Token, or itself.
                attachmentCardByToken[tokenName] = card
            end
        end
    end

    -- Get all objects for purging
    local purgeBag = _getByName('Purge Bag')

    --   Table scan for objects:
    --   Nearest graveyard
    --   Attachment token objects on planet
    --   Attachment cards
    --   Owner tokens on planet
    --   Planet card for planet
    local graveyard = false
    local bestDistanceSq = false
    local p1 = attachTokenObject.getPosition()
    local attachmentTokensOnPlanet = {}
    local attachmentCardGuidByName = {}
    local ownerTokensOnPlanet = {}
    local planetCard = false
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Bag' and string.match(object.getName(), '^TI4 Graveyard') then
            local p2 = object.getPosition()
            local dSq = (p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2
            if not bestDistanceSq or dSq < bestDistanceSq then
                graveyard = object
                bestDistanceSq = dSq
            end
        elseif attachmentCardByToken[object.getName()] then -- Checks if it's an attachment token (not Mirage)
            -- If it's on planet, keep track of attachment token.
            local pfpParams = {
                systemGuid = systemObject.getGUID(),
                position = object.getPosition(),
                exact = true
            }
            local pfp = _systemHelper.planetFromPosition(pfpParams)
            if pfp and pfp.name == planetName then
                table.insert(attachmentTokensOnPlanet, object.getGUID())
            end
        elseif exploreCardToTokenMap[object.getName()] then -- Checks if it's an attachment card
            attachmentCardGuidByName[object.getName()] = object.getGUID()
        elseif string.match(object.getName(), ' Owner Token$') then
            -- If it's on planet, keep track of owner token.
            local pfpParams = {
                systemGuid = systemObject.getGUID(),
                position = object.getPosition(),
                exact = true
            }
            local pfp = _systemHelper.planetFromPosition(pfpParams)
            if pfp and pfp.name == planetName then
                table.insert(ownerTokensOnPlanet, object.getGUID())
            end
        elseif object.getName() == planetName then
            planetCard = object.getGUID()
        end
    end
    assert(graveyard)
    coroutine.yield(0)

    -- Get ground forces on planet, and send them to the graveyard
    local systemHex = _systemHelper.hexFromPosition(systemObject.getPosition())
    local units = _unitHelper.getUnits()
    local removeUnits = {}
    for _, unit in ipairs(units) do
        if unit.hex == systemHex then
            -- Restrict to Ground Forces and Structures
            if unit.unitType == 'Infantry' or unit.unitType == 'Mech' or unit.unitType == 'Space Dock' or unit.unitType == 'PDS' then
                -- Check if it's on the planet (exactly)
                local pfpParams = {
                    systemGuid = systemObject.getGUID(),
                    position = unit.position,
                    exact = true
                }
                local pfp = _systemHelper.planetFromPosition(pfpParams)
                if pfp and pfp.name == planetName then
                    table.insert(removeUnits, unit)
                end
            end
        end  
    end
    coroutine.yield(0)

    for _, unit in ipairs(removeUnits) do
        local unitObject = getObjectFromGUID(unit.guid)
        if unitObject then
            graveyard.putObject(unitObject)
            coroutine.yield(0)
        end
    end

    -- Get owner tokens on planet, and send them to the graveyard
    for _, ownerToken in ipairs(ownerTokensOnPlanet) do
        local object = getObjectFromGUID(ownerToken)
        if object then
            graveyard.putObject(object)
            coroutine.yield(0)
        end
    end

    if purgeBag then
        -- Get list of attachment tokens on planet, purge token and associated card
        for _, attachTokenOnPlanet in ipairs(attachmentTokensOnPlanet) do
            local attachTokenOnPlanetObject = getObjectFromGUID(attachTokenOnPlanet)
            if attachTokenOnPlanetObject then
                -- Does this token have an associated card?
                local attachCardName = attachmentCardByToken[attachTokenOnPlanetObject.getName()]
                if attachCardName then
                    -- Did we find the card, and therefore have it's GUID?
                    local attachCard = attachmentCardGuidByName[attachCardName]
                    if attachCard then
                        -- Is the card object still on the table?
                        local attachCardObject = getObjectFromGUID(attachCard)
                        if attachCardObject then
                            purgeBag.putObject(attachCardObject)
                            coroutine.yield(0)
                        end
                    end
                end

                attachTokenOnPlanetObject.setLock(false)
                purgeBag.putObject(attachTokenOnPlanetObject)
                coroutine.yield(0)
            end
        end

        -- Get planet card, and purge it.
        if planetCard then
            local planetCardObject = getObjectFromGUID(planetCard)
            if planetCardObject then
                purgeBag.putObject(planetCardObject)
                coroutine.yield(0)
            end
        end
    end

    -- Place token directly on planet, and lock it
    attachTokenObject.setLock(false)
    local planetPosition = systemObject.positionToWorld(planet.position)
    local tokenPosition = { x = planetPosition.x, y = planetPosition.y + 0.5, z = planetPosition.z }
    local collide = false
    local fast = true
    attachTokenObject.setPositionSmooth(tokenPosition, collide, fast)

    local function condition()
        if attachTokenObject.isSmoothMoving() then
            return false
        end
        if not attachTokenObject.resting then
            return false
        end
        return true
    end
    local function action()
        attachTokenObject.setLock(true)
    end
    local function timeout() end
    Wait.condition(action, condition, 3, timeout)

    -- Clear context menu
    attachTokenObject.clearContextMenu()

    -- Inject planet with no stats
    planet.resources = 0
    planet.influence = 0
    planet.tech = nil
    planet._attachments = nil
    _systemHelper.injectSystem(system)

    return 1
end

function _stellarConveterTokenDestroyPlanet(system, planetName, attachToken)
    assert(system)
    assert(planetName)
    assert(attachToken)

    table.insert(_stellarConveterTokenDestroyPlanetQueue, {
        system = system,
        planetName = planetName,
        attachToken = attachToken
    })
    startLuaCoroutine(self, '_stellarConveterTokenDestroyPlanet_coroutine')
end

function _stellarConverterTokenInjectFunction(system, planetName, attachTokenObject)
    if not system then
        return false
    end

    if not planetName then
        printToAll('Stellar Converter must be placed on a planet.', 'Yellow')
        return false
    end

    if system.home then
        printToAll('Cannot use Stellar Converter on a home system planet.', 'Yellow')
        return false
    end

    local systemObject = assert(getObjectFromGUID(system.guid))
    local planet = false
    for _, systemPlanet in ipairs(system.planets or {}) do
        if planetName == systemPlanet.name then
            planet = systemPlanet
            break
        end
    end
    assert(planet)

    if planet.legendary then
        printToAll('Cannot use Stellar Converter on a Legendary planet.', 'Yellow')
        return false
    end

    -- 'Hover' over target planet (don't disrupt units, tokens, etc.)
    local planetPosition = systemObject.positionToWorld(planet.position)
    local tokenPosition = { x = planetPosition.x, y = planetPosition.y + 5, z = planetPosition.z }
    local collide = false
    local fast = true
    attachTokenObject.setPositionSmooth(tokenPosition, collide, fast)

    -- Lock in mid-air as soon as moving finishes.
    local function condition()
        if attachTokenObject.isSmoothMoving() then
            return false
        end
        return true
    end
    local function action()
        attachTokenObject.setLock(true)
    end
    local function timeout() end
    Wait.condition(action, condition, 3, timeout)

    -- Add context menu item to ACTUALLY destroy planet. Serves as a confirmation step.
    attachTokenObject.addContextMenuItem('Destroy ' .. planetName, function(playerColor) _stellarConveterTokenDestroyPlanet(system, planetName, attachTokenObject.getGUID()) end, false)

    return system
end

function _stellarConverterTokenEjectFunction(system, planetName, attachTokenObject)
    -- Clear context menu
    attachTokenObject.clearContextMenu()

    if not system then
        return false
    end

    if not planetName then
        return false
    end

    -- Stellar Converter action wasn't ever confirmed
    if not system._stellarConverterPlanet then
        return false
    end

    -- Restore planet stats
    local restorePlanet = system._stellarConverterPlanet
    system._stellarConverterPlanet = nil

    local destroyedPlanet = false
    for _, systemPlanet in ipairs(system.planets or {}) do
        if systemPlanet.name == restorePlanet.name then
            destroyedPlanet = systemPlanet
        end
    end
    -- This overwrites any changes players somehow made since the Stellar Converter happened...okay for now.
    destroyedPlanet.resources = restorePlanet.resources
    destroyedPlanet.influence = restorePlanet.influence
    destroyedPlanet.tech = restorePlanet.tech
    destroyedPlanet._attachments = restorePlanet._attachments

    -- Find purge bag
    local purgeBag = _getByName('Purge Bag')
    if not purgeBag then
        return system
    end
    
    -- Restore purged items
    --   Planet card
    --   Attachment tokens on planet
    --   Attachment cards associated with tokens
    -- (Let players restore units themselves; the graveyard activity was reported.)
    if purgeBag then
        -- Get map of attach token name to card name
        local attachmentCardByToken = {}
        if restorePlanet._attachments then
            for card, tokens in pairs(exploreCardToTokenMap) do
                for _, tokenName in ipairs(tokens or {}) do
                    -- Check if the token was on the planet when it was destroyed.
                    -- NOTE: This won't catch attachments after save/load. Consider reading planet card decals instead.
                    if restorePlanet._attachments[tokenName] then
                        attachmentCardByToken[tokenName] = card
                    end
                end
            end
        end

        local systemObject = getObjectFromGUID(system.guid)
        local unpurgePosition = systemObject.positionToWorld(restorePlanet.position)
        unpurgePosition = { x = unpurgePosition.x, y = unpurgePosition.y + 0.5, z = unpurgePosition.z }
        local unpurgeDz = -0.5

        for _, purgeObject in ipairs(purgeBag.getObjects()) do
            local unpurge = false
            if purgeObject.name == planetName then
                unpurge = true
            elseif attachmentCardByToken[purgeObject.name] then -- Check if attachment token which was on planet
                unpurge = true
            elseif exploreCardToTokenMap[purgeObject.name] then -- Check if attachment card
                -- Check if associated token was on the card
                for _, cardToken in ipairs(exploreCardToTokenMap[purgeObject.name] or {}) do
                    if attachmentCardByToken[cardToken] then
                        unpurge = true
                        break
                    end
                end
            end

            if unpurge then
                purgeBag.takeObject({
                    guid = purgeObject.guid,
                    position = unpurgePosition,
                    smooth = true,
                })
                unpurgePosition = { x = unpurgePosition.x, y = unpurgePosition.y, z = unpurgePosition.z + unpurgeDz }
            end
        end
    end

    return system
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)
