--- Swank UI MultiRoller
-- @author Plat251
-- @author MrStump for dice rolling functions

--[[
Set unit counts by left/right click (or +/- buttons). Winnu flagship number of enemy non-fighter ships instead.

Play unit modifier cards in your play area (laws anywhere on the table). Toggle PS to use plasma scoring on best unit. Toggle AMD to use anti-mass deflectors.

Click roll type in any unit's attributes.
]]

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local UNIT_TYPES = {
    'Carrier',
    'Cruiser',
    'Destroyer',
    'Dreadnought',
    'Fighter',
    'Flagship',
    'Infantry',
    'PDS',
    'Space Dock',
    'War Sun',
}

local ABILITIES = {
    antiFighterBarrage = "Anti-Fighter",
    bombardment = "Bombardment",
    groundCombat = "Ground Combat",
    spaceCannon = "Space Cannon",
    spaceCombat = "Space Combat",
    sustainDamage = "Sustain Damage",
    planetaryShield = "Planetary Shield",
    disablePlanetaryShield = "Disables Planetary Shield"
}

local DICE_COLOR = {
    ["Dreadnought"] = "Purple",
    ["Flagship"] = "Black",
    ["Destroyer"] = "Red",
    ["War Sun"] = "Orange",
    ["Carrier"] = "Blue",
    ["Fighter"] = "Teal",
    ["Infantry"] = "Green",
    ["Cruiser"] = "Brown",
    ["PDS"] = "Orange",
    ["Space Dock"] = "Yellow",
    ["Mech"] = "Pink"
}

local _unitTypeToCount = {}
local _antiMassDeflectors = false
local _plasmaScoring = false

local _allPossibleUnitAttrs = false
local _unitAttrs = false
local _getUnitDataLastRefreshFrame = false

local _injectExtraUnitUpgrades = false
local _injectExtraModifiers = false
local _updateWarnings = false

function onLoad()
    for _, unitType in ipairs(UNIT_TYPES) do
        _unitTypeToCount[unitType] = 0
    end
    local function delayedCreateUi()
        math.randomseed(tonumber(self.getGUID(), 16)) -- guid may change after spawn
        createUi()
    end
    Wait.time(delayedCreateUi, 0.5)
end

function onPlayerConnect(player_id)
    -- XML UI is sometimes missing if player connects after created, recreate.
    Wait.time(createUi, math.random() * 0.5 + 0.1)
end

-- Update if a player moves it.
function onDrop()
    updateColor()
end

function onPlayerChangeColor(player_color)
    Wait.time(updateColor, 3 + math.random()) -- give it some time in case changing tints
end

function onSetupHelperPlayerCountChanged()
    Wait.time(updateColor, math.random())
end

function onSetupHelperFactionUnpacked()
    Wait.time(updateAbilities, math.random())
end

function createUi()
    -- Use all modifiers that add abilities.  Show/hide them as needed.
    if not _allPossibleUnitAttrs then
        _injectExtraUnitUpgrades = {}
        _injectExtraModifiers = {}
        table.insert(_injectExtraUnitUpgrades, 'War Sun')
        table.insert(_injectExtraModifiers, 'Blitz')
        table.insert(_injectExtraModifiers, 'Experimental Battlestation')
        _allPossibleUnitAttrs = getUnitData(true)

        _allPossibleUnitAttrs['Flagship']['antiFighterBarrage'] = {}
        _allPossibleUnitAttrs['Flagship']['bombardment'] = {}
        _allPossibleUnitAttrs['Flagship']['spaceCannon'] = {}
        _allPossibleUnitAttrs['Flagship']['spaceCombat'] = {}
        _allPossibleUnitAttrs['Flagship']['sustainDamage'] = true
        _allPossibleUnitAttrs['Flagship']['disablePlanetaryShield'] = true

        _allPossibleUnitAttrs['Carrier']['sustainDamage'] = true  -- sol
        _allPossibleUnitAttrs['Infantry']['spaceCombat'] = {}  -- nekro flagship
        _allPossibleUnitAttrs['Fighter']['spaceCombat'] = {}  -- naulo flagship

        _getUnitDataLastRefreshFrame = false  -- make sure not cached!
        _injectExtraUnitUpgrades = false
        _injectExtraModifiers = false
    end

    local xml = generateRollerXmlTable(_allPossibleUnitAttrs)
    self.UI.setXmlTable(xml)

    -- Do not attempt to use the XML on the same frame it is set OR THE NEXT!
    -- It takes TTS a moment to register everything.
    local function delayedUpdate()
        for _, unitType in ipairs(UNIT_TYPES) do
            setUnitCount(unitType, 0)
        end
        for unitType, count in pairs(_unitTypeToCount) do
            setUnitCount(unitType, count)
        end
        setPlasmaScoring(_plasmaScoring)
        setAntiMassDeflectors(_antiMassDeflectors)
        updateAbilities()
        updateColor()
    end
    Wait.frames(delayedUpdate, 3) -- 2 is enough, do 3 to be safe
end

function updateAbilities()
    local unitData = getUnitData()
    for _, unitType in ipairs(UNIT_TYPES) do
        local unitAttrs = unitData[unitType] or {}
        setUnitName(unitType, unitAttrs.name)
        for ability, _ in pairs(ABILITIES) do
            local abilityAttrs = unitAttrs[ability]
            if abilityAttrs then
                if type(abilityAttrs) == 'table' then
                    local value = abilityAttrs.hit
                    if abilityAttrs.dice and abilityAttrs.dice > 1 then
                        value = value .. ' (\u{00D7}' .. abilityAttrs.dice .. ')'
                    end
                    if abilityAttrs.extraDice and abilityAttrs.extraDice > 0 then
                        value = value .. '*'
                    end
                    setAbilityValue(unitType, ability, value)
                else
                    setAbilityValue(unitType, ability, '')
                end
            elseif _allPossibleUnitAttrs[unitType][ability] then
                removeAbility(unitType, ability)
            end
        end
    end
end

function updateColor()
    local color = myColor()
    local tint = false
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == color .. ' War Sun' then
            tint = object.getColorTint()
            break
        end
    end
    tint = tint and ('#' .. Color.new(tint.r, tint.g, tint.b):toHex(false)) or color

    for _, unitType in ipairs(UNIT_TYPES) do
        self.UI.setAttribute(unitType .. '.unitImage', 'color', tint)
    end
end

-------------------------------------------------------------------------------

function generateRollerXmlTable(unit_data)
    local defaultsXmlTable = {
        tag = "Defaults",
        attributes = {},
        children = {
            {
                tag = "Text",
                attributes = {
                    class = "unitNameplate",
                    resizeTextForBestFit = "true",
                    resizeTextMaxSize = "250",
                    color = "#FFFFFF",
                    fontStyle = "Bold",
                    outline = "#000000",
                    outlineSize = "16 -16"
                }
            },
            {
                tag = "Text",
                attributes = {
                    class = "unitAbilities",
                    fontSize = "160",
                    color = "#FFFFFFFF",
                    horizontalOverflow = "Overflow",
                    verticalOverflow = "Overflow"
                }
            },
            {
                tag = "Text",
                attributes = {
                    class = "unitCount",
                    fontSize = "640",
                    color = "#FFFFFFFF",
                    fontStyle = "Bold",
                    horizontalOverflow = "Overflow",
                    outline = "#000000",
                    outlineSize = "4 -4"
                }
            },
            {
                tag = "Text",
                attributes = {
                    class = "hitsCount",
                    height = "800",
                    width = "800",
                    scale = "2 2 2",
                    fontSize = "800",
                    fontStyle = "Bold",
                    color = "#FF0000",
                    outline = "#000000",
                    outlineSize = "16 -16"
                }
            },
            {
                tag = "Text",
                attributes = {
                    class = "userButtonText",
                    fontSize = "400",
                    color = "#FFFFFFFF"
                }
            },
            {
                tag = "Button",
                attributes = {
                    class = "changeCount",
                    width = "360",
                    height = "360",
                    fontSize = "320",
                    fontStyle = "Bold",
                    color = "#00000000",
                    textColor = "#FFFFFF"
                }
            },
            {
                tag = "Button",
                attributes = {
                    class = "UILayoutLightBackground",
                    color = "#00000050"
                }
            },
            {
                tag = "Panel",
                attributes = {
                    class = "UILayoutLightBackground",
                    color = "#00000050"
                }
            },
            {
                tag = "Panel",
                attributes = {
                    class = "UILayoutMediumBackground",
                    color = "#222222"
                }
            },
            {
                tag = "Panel",
                attributes = {
                    class = "UILayoutHeavyBackground",
                    color = "#111111"
                }
            },
            {
                tag = "Button",
                attributes = {
                    class = "UILayoutHeavyBackground",
                    colors = "#111111|#000000|#222222|#222222"
                }
            },
            {
                tag = "ToggleButton",
                attributes = {
                    class = "UILayoutHeavyBackground",
                    color = "#222222",
                    colors = "#000000|#000000|#000000|#000000"
                }
            }
        }
    }
    local containerLayoutXmlTable = {
        tag = "HorizontalLayout",
        attributes = {
            width = "12600",
            height = "6100",
            spacing = "100 100",
            childAlignment = "MiddleCenter",
            position = "0 0 -0.5",
            rotation = "180 180 0",
            scale = "0.098 0.096 1"
        },
        children = {
            {
                tag = "GridLayout",
                attributes = {
                    cellSize = "2000 3000",
                    spacing = "100 100"
                },
                children = {}
            },
            {
                tag = "Panel",
                attributes = {
                    class = "UILayoutLightBackground"
                },
                children = {
                    {
                        tag = "VerticalLayout",
                        attributes = {padding = "50 50 50 50", spacing = "50"},
                        children = {
                            {
                                tag = "ToggleButton",
                                attributes = {
                                    id = "toggleAntiMassDeflectors",
                                    onValueChanged = "toggleAntiMassDeflectors",
                                    class = "UILayoutHeavyBackground",
                                    isOn = "false"
                                },
                                children = {
                                    {
                                        tag = "Text",
                                        value = "Anti-Mass Deflectors",
                                        attributes = {
                                            class = "userButtonText"
                                        }
                                    }
                                }
                            },
                            {
                                tag = "ToggleButton",
                                attributes = {
                                    id = "togglePlasmaScoring",
                                    onValueChanged = "togglePlasmaScoring",
                                    class = "UILayoutHeavyBackground",
                                    isOn = "false"
                                },
                                children = {
                                    {
                                        tag = "Text",
                                        value = "Plasma Scoring",
                                        attributes = {
                                            class = "userButtonText"
                                        }
                                    }
                                }
                            },
                            {
                                tag = "Button",
                                attributes = {
                                    onClick = "updateRoller",
                                    class = "UILayoutHeavyBackground"
                                },
                                children = {
                                    {
                                        tag = "Text",
                                        value = "Update",
                                        attributes = {
                                            class = "userButtonText"
                                        }
                                    }
                                }
                            },
                            {
                                tag = "Button",
                                attributes = {
                                    onClick = "resetRoller",
                                    class = "UILayoutHeavyBackground"
                                },
                                children = {
                                    {
                                        tag = "Text",
                                        value = "Reset",
                                        attributes = {
                                            class = "userButtonText"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    local xmlTable = {}
    table.insert(xmlTable, table.unpack({defaultsXmlTable}))
    table.insert(xmlTable, table.unpack({containerLayoutXmlTable}))

    -- Layout in UNIT_TYPES list order.
    local color = myColor()
    for _, unit_id in ipairs(UNIT_TYPES) do
        local unit_stats = unit_data[unit_id] or {}
        table.insert(xmlTable[2]["children"][1]["children"], generateUnitXmlTable(unit_id, unit_stats, color))
    end
    return xmlTable
end

function generateUnitXmlTable(unit_id, unit_stats, color)
    return {
        tag = "Button",
        attributes = {
            id = unit_id .. ".unitMainButton",
            class = "UILayoutLightBackground",
            onClick = "changeUnitCountXml",
            onMouseEnter = "showChangeCountButtonsXml",
            onMouseExit = "hideChangeCountButtonsXml",
            width = "2000",
            height = "3000"
        },
        children = {
            {
                tag = "VerticalLayout",
                attributes = {},
                children = {
                    {
                        tag = "Image",
                        attributes = {
                            id = unit_id .. ".UnitImage",
                            image = unit_stats["image"] or "MissingImage!",
                            preferredWidth = "2000",
                            preferredHeight = "2000",
                            preserveAspect = "true",
                            color = color or myColor()
                        },
                        children = {
                            {
                                tag = "Text",
                                value = unit_stats["name"] or "MissingUnitName!",
                                attributes = {
                                    id = unit_id .. ".unitName",
                                    class = "unitNameplate",
                                    offsetXY = "0 -550",
                                    rectAlignment = "LowerCenter"
                                }
                            },
                            {
                                tag = "Text",
                                value = _unitTypeToCount[unit_id] or 0,
                                attributes = {
                                    id = unit_id .. ".unitCount",
                                    class = "unitCount",
                                    offsetXY = "720 640",
                                    rectAlignment = "UpperRight"
                                }
                            },
                            {
                                tag = "Button",
                                value = "-",
                                attributes = {
                                    id = unit_id .. ".unitCountDecrement",
                                    active = "false",
                                    onClick = "changeUnitCountXml(-1)",
                                    class = "changeCount",
                                    offsetXY = "-1600 200",
                                    rectAlignment = "LowerRight",
                                    showAnimation = "FadeIn",
                                    hideAnimation = "FadeOut"
                                }
                            },
                            {
                                tag = "Button",
                                value = "+",
                                attributes = {
                                    id = unit_id .. ".unitCountIncrement",
                                    active = "false",
                                    onClick = "changeUnitCountXml(1)",
                                    class = "changeCount",
                                    offsetXY = "1600 200",
                                    rectAlignment = "LowerLeft",
                                    showAnimation = "FadeIn",
                                    hideAnimation = "FadeOut"
                                }
                            },
                            {
                                tag = "Text",
                                value = "",
                                attributes = {
                                    id = unit_id .. ".hitsCount",
                                    class = "hitsCount"
                                },
                                children = {}
                            }
                        }
                    },
                    {
                        tag = "Panel",
                        attributes = {class = "UILayoutMediumBackground", preferredHeight = "1400"},
                        children = {
                            {
                                tag = "VerticalLayout",
                                attributes = {padding = "40 40 40 40", spacing = "40"},
                                children = generateUnitAbilitiesXmlTable(unit_id, unit_stats)
                            }
                        }
                    }
                }
            }
        }
    }
end

function generateUnitAbilitiesXmlTable(unit_id, unit_stats)
    local unitAbilitiesXmlTable = {}
    for ability_id, ability_details in pairs(unit_stats) do
        if ABILITIES[ability_id] then
            table.insert(unitAbilitiesXmlTable, generateUnitAbility(unit_id, ability_id, ability_details))
        end
    end
    return unitAbilitiesXmlTable
end

function generateUnitAbility(unit_id, ability_id, ability_details)
    local onClickValue
    if type(ability_details) == 'table' then
        onClickValue = "rollDiceForAbility(" .. string.sub(ability_id, 1, -1) .. ")"
    else
        onClickValue = "doNothing"
    end
    return {
        tag = "Button",
        attributes = {
            id = unit_id .. ".ability." .. ability_id,
            class = "UILayoutHeavyBackground",
            onClick = onClickValue
        },
        children = {
            {
                tag = "Panel",
                attributes = {
                    childAlignment = "MiddleLeft"
                },
                children = {
                    {
                        tag = "Text",
                        value = ABILITIES[ability_id] or "MissingUnitAbility!",
                        attributes = {
                            class = "unitAbilities",
                            alignment = "MiddleLeft",
                            ignoreLayout = "true",
                            offsetXY = "96 0"
                        }
                    },
                    {
                        tag = "Text",
                        value = "",
                        attributes = {
                            id = unit_id .. ".ability." .. ability_id .. ".value",
                            class = "unitAbilities",
                            ignoreLayout = "true",
                            alignment = "MiddleRight",
                            offsetXY = "-96 0"
                        }
                    }
                }
            }
        }
    }
end

function doNothing()
end

function setUnitName(unit_id, value)
    self.UI.setValue(unit_id .. ".unitName", value)
end

function setAbilityValue(unit_id, ability_id, value)
    self.UI.show(unit_id .. ".ability." .. ability_id)
    self.UI.setValue(unit_id .. ".ability." .. ability_id .. ".value", value)
end

function removeAbility(unit_id, ability_id)
    self.UI.hide(unit_id .. ".ability." .. ability_id)
end

function changeUnitCountXml(player, value, id)
    if (not player.seated) or player.color == 'Grey' then
        return
    end
    if id == string.match(id, ".+%.") .. "unitMainButton" then
        if value == "-1" then
            value = "1"
        elseif value == "-2" then
            value = "-1"
        else
            value = 0
        end
    end

    local unitType = string.match(id, "^(.+)%.")
    local oldValue = getUnitCount(unitType)
    local newValue = oldValue + value

    -- Clamp.
    newValue = math.max(0, newValue)
    newValue = math.min(99, newValue)

    setUnitCount(unitType, newValue)

    -- If changing between zero and one, reset UI (in case plasma scoring moves).
    if oldValue + newValue == 1 then
        updateAbilities()
    end
end

function showChangeCountButtonsXml(player, value, id)
    local unitIncrementId = string.match(id, "(.+)%.") .. ".unitCountIncrement"
    local unitDecrementId = string.match(id, "(.+)%.") .. ".unitCountDecrement"
    self.UI.show(unitIncrementId)
    self.UI.show(unitDecrementId)
end

function hideChangeCountButtonsXml(player, value, id)
    local unitIncrementId = string.match(id, "(.+)%.") .. ".unitCountIncrement"
    local unitDecrementId = string.match(id, "(.+)%.") .. ".unitCountDecrement"
    self.UI.hide(unitIncrementId)
    self.UI.hide(unitDecrementId)
end

-------------------------------------------------------------------------------

function to_boolean(string)
    if string:lower() == "true" then
        return true
    elseif string:lower() == "false" then
        return false
    else
        return
    end
end

function setUnitCount(unit, count)
    assert(type(unit) == 'string' and type(count) == 'number')
    self.UI.setValue(unit .. ".unitCount", count)
    _unitTypeToCount[unit] = count
end

function getUnitCount(unit)
    assert(type(unit) == 'string')
    -- If the UI was (re)generated this frame it might not be safe to read.
    --return tonumber(self.UI.getValue(unit .. ".unitCount"))
    return _unitTypeToCount[unit]
end

function setHitCount(unit, hits)
    self.UI.setValue(unit .. ".hitsCount", hits)
end

function setAntiMassDeflectors(value)
    self.UI.setAttribute("toggleAntiMassDeflectors", "isOn", value)
    _antiMassDeflectors = value
end

function setPlasmaScoring(value)
    self.UI.setAttribute("togglePlasmaScoring", "isOn", value)
    _plasmaScoring = value
end

function toggleAntiMassDeflectors()
    setAntiMassDeflectors(not getAntiMassDeflectors())
    updateAbilities()
end

function togglePlasmaScoring()
    setPlasmaScoring(not getPlasmaScoring())
    updateAbilities()
end

function getAntiMassDeflectors()
    --return self.UI.getAttribute("toggleAntiMassDeflectors", "isOn")
    return _antiMassDeflectors
end

function getPlasmaScoring()
    --return self.UI.getAttribute("togglePlasmaScoring", "isOn")
    return _plasmaScoring
end

function updateRoller()
    updateAbilities()

    local unitData = getUnitData()
    printUnitModifiers(unitData)
end

function resetRoller()
    Roller.reset()
    for unit, _ in pairs(getUnitData()) do
        setUnitCount(unit, 0)
        setHitCount(unit, "")
    end
    setAntiMassDeflectors(false)
    setPlasmaScoring(false)
    updateAbilities()
    updateColor()
end

-------------------------------------------------------------------------------

-- Split out dice rolling into this self-contained "class".
Roller = {
    DICE_POSITION_RADIUS_X = 8,
    DICE_POSITION_RADIUS_Z = 4,
    DICE_POSITION_HEIGHT = 4,

    _dice = {},
    _rollInProgressTimestamp = false,
    _rollQueue = {}
}

function Roller.isRollInProgress()
    local timeout = Roller._rollInProgressTimestamp and (Roller._rollInProgressTimestamp + 10)
    return timeout and (timeout > Time.time)
end

function Roller._setRollInProgress(isActive)
    assert(type(isActive) == 'boolean')
    Roller._rollInProgressTimestamp = isActive and Time.time or false
end

function Roller.reset()
    Roller._removeDice()
    Roller._dice = {}
end

function Roller._removeDice()
    for _, dice in ipairs(Roller._dice) do
        for _, guid in ipairs(dice._guids or {}) do
            local object = getObjectFromGUID(guid)
            if object then
                destroyObject(object)
            end
        end
        dice._guids = nil
    end
end

function Roller.addDice(params)
    assert(type(params.diceColor) == 'string', 'bad diceColor')
    assert(type(params.diceCount) == 'number', 'bad diceCount')
    assert(type(params.unitName) == 'string', 'bad unitName')
    assert(type(params.hitValue) == 'number', 'bad hitValue')
    assert((not params.critValue) or type(params.critValue) == 'number', 'bad critValue')
    assert((not params.critCount) or type(params.critCount) == 'number', 'bad critCount')

    -- Make a copy in case original gets mutated somehow.
    local copy = {}
    for k, v in pairs(params) do
        copy[k] = v
    end
    table.insert(Roller._dice, copy)
end

function Roller.roll(clickerColor, playerColor, rollLabel)
    assert(type(clickerColor) == 'string', 'bad clickerColor')
    assert(type(playerColor) == 'string', 'bad playerColor')
    assert(type(rollLabel) == 'string', 'bad rollLabel')

    local playerName = Player[playerColor] and Player[playerColor].steam_name or playerColor
    table.insert(Roller._rollQueue, {
        clickerColor = clickerColor,
        playerColor = playerColor,
        playerName = playerName,
        rollLabel = rollLabel
    })
    startLuaCoroutine(self, 'Roller_RollDiceCoroutine')
end

function Roller._getDieSpawnPosition(unitIndex, dieCount, dieIndex)
    assert(type(unitIndex) == 'number' and type(dieCount) == 'number' and type(dieIndex) == 'number')
    local bounds = self.getBounds()
    local d = 5
    local dScale = {
        x = d * 1,
        z = d * self.getPosition().z > 0 and 1 or -1
    }
    local bottomCenterBottom = {
        x = bounds.center.x * dScale.x,
        z = bounds.center.z + dScale.z * (bounds.size.z / 2)
    }
    return {
        x = bottomCenterBottom.x - (dieCount * dScale.x / 2) + ((dieIndex - 0.5) * dScale.x),
        y = self.getPosition().y + Roller.DICE_POSITION_HEIGHT,
        z = bottomCenterBottom.z + (dScale.z / 2) + (unitIndex * dScale.z)
    }
end

function Roller._randomRotation()
    --Credit for this function goes to Revinor (forums)
    --Get 3 random numbers
    local u1 = math.random()
    local u2 = math.random()
    local u3 = math.random()
    --Convert them into quats to avoid gimbal lock
    local u1sqrt = math.sqrt(u1)
    local u1m1sqrt = math.sqrt(1-u1)
    local qx = u1m1sqrt *math.sin(2*math.pi*u2)
    local qy = u1m1sqrt *math.cos(2*math.pi*u2)
    local qz = u1sqrt *math.sin(2*math.pi*u3)
    local qw = u1sqrt *math.cos(2*math.pi*u3)
    --Apply rotation
    local ysqr = qy * qy
    local t0 = -2.0 * (ysqr + qz * qz) + 1.0
    local t1 = 2.0 * (qx * qy - qw * qz)
    local t2 = -2.0 * (qx * qz + qw * qy)
    local t3 = 2.0 * (qy * qz - qw * qx)
    local t4 = -2.0 * (qx * qx + ysqr) + 1.0
    --Correct
    if t2 > 1.0 then t2 = 1.0 end
    if t2 < -1.0 then ts = -1.0 end
    --Convert back to X/Y/Z
    local xr = math.asin(t2)
    local yr = math.atan2(t3, t4)
    local zr = math.atan2(t1, t0)
    --Return result
    return {math.deg(xr),math.deg(yr),math.deg(zr)}
end

function Roller_RollDiceCoroutine()
    local params = table.remove(Roller._rollQueue)
    if not params then
        return 1
    end
    local clickerColor = params.clickerColor
    local playerColor = params.playerColor
    local playerName = params.playerName
    local rollLabel = params.rollLabel

    if Roller.isRollInProgress() then
        printToColor('Dice are already being rolled.', clickerColor, {0.8,0.2,0.2})
        return 1
    end
    if #Roller._dice == 0 then
        printToColor('No valid units for ' .. rollLabel, clickerColor, {0.8,0.2,0.2})
        return 1
    end
    Roller._setRollInProgress(true)
    printToAll(playerName .. ' rolling for ' .. rollLabel, playerColor)

    math.randomseed(os.time())

    -- Remove any existing dice.
    Roller._removeDice()

    -- Create dice, with random initial rotations.
    local totalDiceCount = 0
    for _, dice in ipairs(Roller._dice) do
        totalDiceCount = totalDiceCount + dice.diceCount
    end
    for unitIndex, dice in ipairs(Roller._dice) do
        dice._objects = {}
        for dieIndex = 1, dice.diceCount do
            local die = spawnObject({
                type = 'Die_10',
                position = Roller._getDieSpawnPosition(unitIndex, dice.diceCount, dieIndex),
                rotation = Roller._randomRotation(),
            })
            die.setName(dice.unitName)
            die.setColorTint(Color.fromString(dice.diceColor))
            die.use_grid = false
            die.use_snap_points = false
            die.use_hands = false
            table.insert(dice._objects, die)
        end
    end
    for _, dice in ipairs(Roller._dice) do
        dice._guids = {}  -- not safe to read immediately after spawn, can change
        for _, die in pairs(dice._objects) do
            while die.spawning do
                coroutine.yield(0)
            end
            table.insert(dice._guids, die.getGUID())
        end
        dice._objects = nil
    end
    coroutine.yield(0)

    -- Roll!
    for _, dice in ipairs(Roller._dice) do
        for _, guid in ipairs(dice._guids) do
            local die = getObjectFromGUID(guid)
            die.interactable = false
            die.roll()
        end
    end
    coroutine.yield(0)

    -- Wait for dice, extract roll values.
    local timeout = Time.time + 3
    for _, dice in ipairs(Roller._dice) do
        dice._rollValues = {}
        for _, guid in ipairs(dice._guids) do
            local die = false
            while true do
                die = getObjectFromGUID(guid)  -- re-get every time, can be deleted
                if die and (not die.resting) and Time.time < timeout then
                    coroutine.yield(0)
                else
                    break
                end
            end
            if die then
                table.insert(dice._rollValues, die.getValue() or 0)
                die.interactable = true
            end
        end
    end
    coroutine.yield(0)

    -- Generate report.
    local message = {}
    local hits = 0
    for _, dice in ipairs(Roller._dice) do
        local item = '[HIT:' .. dice.hitValue
        if dice.critCount and dice.critValue then
            item = item .. ', CRIT(x' .. (dice.critCount + 1) .. '):' .. dice.critValue
        end
        item = item .. ']: '

        local rollValues = {}
        local unitHitCount = 0
        for _, rollValue in ipairs(dice._rollValues) do
            local suffix = ''
            if rollValue >= dice.hitValue then
                hits = hits + 1
                unitHitCount = unitHitCount + 1
                suffix = '#'
            end
            if dice.critCount and dice.critValue and rollValue >= dice.critValue then
                hits = hits + dice.critCount
                unitHitCount = unitHitCount + dice.critCount
                for _ = 1, dice.critCount do
                    suffix = suffix .. '#'
                end
            end
            table.insert(rollValues, rollValue .. suffix)
            setHitCount(dice.unitId, unitHitCount)
        end
        table.insert(message, dice.unitName .. ' ' .. item .. table.concat(rollValues, ', '))
    end
    broadcastToAll(playerName .. ' rolled: [ffffff]' .. table.concat(message, ', '), playerColor)
    broadcastToAll(playerName .. ' landed ' .. hits .. ' hit' .. (hits == 1 and '' or 's') .. '.', playerColor)

    Roller._setRollInProgress(false)
    return 1
end

-------------------------------------------------------------------------------

function rollDiceForAbility(player, ability)
    if (not player.seated) or player.color == 'Grey' then
        return
    end
    local clickerColor = player and player.color or myColor()
    local playerZoneColor = myColor() or clickerColor

    if Roller.isRollInProgress() then
        broadcastToColor("Dice are already being rolled.", clickerColor, {0.8, 0.2, 0.2})
        return
    end

    local unitData = getUnitData()
    printUnitModifiers(unitData)

    for unit, _ in pairs(unitData) do
        setHitCount(unit, "")
    end
    Roller.reset()

    for unit_id, unit_stats in pairs(unitData) do
        local unit_count = getUnitCount(unit_id) or 0
        if unit_count > 0 and unit_stats[ability] then
            local params = {
                diceColor = DICE_COLOR[unit_id],
                diceCount = unit_stats[ability].dice * unit_count + (unit_stats[ability].extraDice or 0),
                hitValue = unit_stats[ability].hit,
                unitName = unit_stats.name,
                unitId = unit_id
            }
            Roller.addDice(params)
        end
    end
    Roller.roll(clickerColor, playerZoneColor, ABILITIES[ability])
end

function printUnitModifiers(unitAttrs, dstColor)
    local modifiers = {}
    for _, modifier in ipairs(unitAttrs._flagshipModifiers) do
        table.insert(modifiers, modifier.name .. ' (' .. modifier.description .. ')')
    end
    for _, modifier in ipairs(unitAttrs._unitModifiers) do
        table.insert(modifiers, modifier.name .. ' (' .. modifier.description .. ')')
    end
    local msg = 'Roll Modifiers detected: ' .. ((#modifiers > 0) and table.concat(modifiers, ', ') or 'none')
    for _, warning in ipairs(_updateWarnings or {}) do
        msg = msg .. '\n' .. 'WARNING: ' .. warning
    end
    local msgColor = assert(myColor())
    if dstColor then
        printToColor(msg, dstColor, msgColor)
    else
        printToAll(msg, msgColor)
    end
end

-------------------------------------------------------------------------------

function myColor()
    local p0 = self.getPosition()
    local best = false
    local bestDistanceSq = false
    for _, attrs in ipairs(_zoneHelper.zonesAttributes()) do
        local p1 = attrs.center
        local dSq = (p0.x - p1.x) ^ 2 + (p0.z - p1.z) ^ 2
        if (not best) or dSq < bestDistanceSq then
            best = attrs.color
            bestDistanceSq = dSq
        end
    end
    return best or 'Grey'
end

function getUnitData(force)
    if _unitAttrs and (not force) and _getUnitDataLastRefreshFrame == Time.frame_count then
        return _unitAttrs
    end
    _getUnitDataLastRefreshFrame = Time.frame_count

    _updateWarnings = false
    local color = myColor()

    local unitTypeToCount = {}
    for _, unitType in ipairs(UNIT_TYPES) do
        unitTypeToCount[unitType] = getUnitCount(unitType)
    end

    local unitOverrides = _unitHelper.getColorToUnitOverrides()[color] or {}
    local unitModifiers = _unitHelper.getColorToUnitModifiers()[color] or {}

    -- Remove PS if not selected.
    if getPlasmaScoring() then
        local found = false
        for _, modifier in ipairs(unitModifiers) do
            if modifier == 'Plasma Scoring' then
                found = true
                break
            end
        end
        if not found then
            -- Plasma scoring not detected, but is enabled.
            _updateWarnings = _updateWarnings or {}
            table.insert(_updateWarnings, 'PS enabled but missing Plasma Scoring technology')
            table.insert(unitModifiers, 'Plasma Scoring')
        end
    else
        for i = #unitModifiers, 1, -1 do
            if unitModifiers[i] == 'Plasma Scoring' then
                -- Plasma scoring detected, but disabled.
                _updateWarnings = _updateWarnings or {}
                table.insert(_updateWarnings, 'PS disabled but have Plasma Scoring technology')
                table.remove(unitModifiers, i)
            end
        end
    end

    -- Let others add unit overrides and modifiers.
    if _injectExtraUnitUpgrades then
        local unitOverridesSet = {}
        for _, unitOverride in ipairs(unitOverrides) do
            unitOverridesSet[unitOverride] = true
        end
        for _, unitOverride in ipairs(_injectExtraUnitUpgrades) do
            if not unitOverridesSet[unitOverride] then
                table.insert(unitOverrides, unitOverride)
            end
        end
    end
    if _injectExtraModifiers then
        local unitModifiersSet = {}
        for _, unitModifier in ipairs(unitModifiers) do
            unitModifiersSet[unitModifier] = true
        end
        for _, unitModifier in ipairs(_injectExtraModifiers) do
            if not unitModifiersSet[unitModifier] then
                table.insert(unitModifiers, unitModifier)
            end
        end
    end

    _unitAttrs = _unitHelper.getUnitAttributes(unitOverrides)

    -- Apply flagships.
    _unitAttrs = _unitHelper.applyFlagshipModifiers({
        unitAttrs = assert(_unitAttrs),
        myUnitTypeToCount = unitTypeToCount,
        opponentUnitTypeToCount = false
    })

    -- Apply unit modifiers.
    _unitAttrs = _unitHelper.applyUnitModifiers({
        unitAttrs = assert(_unitAttrs),
        myColor = color,
        myUnitModifiers = unitModifiers,
        myUnitTypeToCount = unitTypeToCount,
        opponentColor = false,
        opponentUnitModifiers = getAntiMassDeflectors() and { 'Antimass Deflectors' },
        opponentUnitTypeToCount = false
    })

    -- Make sure all units have a name and image.
    for unitType, unitAttrs in pairs(_unitAttrs) do
        unitAttrs.name = unitAttrs.name or unitType
        unitAttrs.image = unitAttrs.image or unitType
        --unitAttrs.image = 'MuaatButton'
    end

    return _unitAttrs
end

-------------------------------------------------------------------------------

--- Let outsiders ("auto-fill multiroller") set values and optionally roll.
function inject(params)
    assert(type(params) == 'table')
    assert(type(params.clickerColor) == 'string')
    assert(type(params.unitTypeToCount) == 'table')
    assert(type(params.plasmaScoring) == 'boolean')
    assert(type(params.antimassDeflectors) == 'boolean')
    assert((not params.rollType) or type(params.rollType) == 'string')
    assert((not params.extraModifiers) or type(params.extraModifiers) == 'table')

    if params.clickerColor == 'Grey' then
        return
    end

    -- Add these when gathering unit modifiers.
    _injectExtraModifiers = params.extraModifiers or false

    for _, unitType in ipairs(UNIT_TYPES) do
        setUnitCount(unitType, 0)
    end
    for unitType, count in pairs(params.unitTypeToCount) do
        setUnitCount(unitType, count)
    end

    setPlasmaScoring(params.plasmaScoring and true or false)
    setAntiMassDeflectors(params.antimassDeflectors and true or false)

    updateAbilities()

    rollDiceForAbility(false, params.rollType)

    -- Require click handling absorb these this frame, otherwise lost.
    _injectExtraModifiers = false
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)
